<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lincx_py</title>
  
  <subtitle>预防掉发，多敲代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lincx_py.gitee.io/"/>
  <updated>2021-03-21T10:56:14.444Z</updated>
  <id>https://lincx_py.gitee.io/</id>
  
  <author>
    <name>lincx_py</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统学习笔记3</title>
    <link href="https://lincx_py.gitee.io/2021/03/21/operator01/"/>
    <id>https://lincx_py.gitee.io/2021/03/21/operator01/</id>
    <published>2021-03-21T10:54:42.000Z</published>
    <updated>2021-03-21T10:56:14.444Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><p>[toc]</p><h2 id="操作系统的四大特性"><a href="#操作系统的四大特性" class="headerlink" title="操作系统的四大特性"></a>操作系统的四大特性</h2><ul><li>并发：同一段时间内多个程序执行</li><li>共享：系统中的资源可以被内存中多个并发执行的进线程共同使用</li><li>虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个</li><li>异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进</li></ul><h2 id="操作系统基本功能"><a href="#操作系统基本功能" class="headerlink" title="操作系统基本功能"></a>操作系统基本功能</h2><ul><li><p>进程管理</p><p>：</p><ul><li>进程控制、进程同步、进程通信、死锁处理、处理机调度等</li></ul></li><li><p>内存管理</p><p>：</p><ul><li>内存分配、地址映射、内存保护与共享、虚拟内存等</li></ul></li><li><p>文件管理</p><p>：</p><ul><li>文件存储空间的管理、目录管理、文件读写管理和保护等</li></ul></li><li><p>设备管理</p><p>：</p><ul><li>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等</li></ul></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ul><li>CPU（中央处理器）</li><li>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础</li><li><strong>资源分配的最小单位是进程，而CPU调度的最小单位是时间片</strong></li><li>系统为进程分配资源，不对线程分配资源</li></ul><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><ul><li>高级调度（作业调度）：<ul><li>多道批处理操作系统中，从输入系统的一批作业中按照预定的调度策略挑选若干作业进入内存，为其分配资源并创建对应的作业用户进程</li><li>作业是任务实体，进程是完成任务的执行实体。<strong>作业的概念多用于批处理操作系统，而进程用于各种多道程序设计系统</strong></li></ul></li><li>中级调度<ul><li>根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作（挂起）。起到短期均衡系统负载的作用</li></ul></li><li>低级调度（进程调度/线程调度）<ul><li><strong>根据某种原则决定就绪队列中哪个进程/线程获得处理器，并将处理器出让给它使用</strong></li></ul></li></ul><h3 id="Q：某一进程CPU使用率-50-是什么意思？"><a href="#Q：某一进程CPU使用率-50-是什么意思？" class="headerlink" title="Q：某一进程CPU使用率 50% 是什么意思？"></a>Q：某一进程CPU使用率 50% 是什么意思？</h3><ul><li>CPU使用率是来描述CPU的使用情况的，表明了一段时间内CPU被占用的情况。使用率越高，说明你的机器在这个时间上运行了很多程序，反之较少。使用率的高低与你的CPU强弱有直接关系。</li><li>CPU的占用率，一般指的就是对时间片的占用情况，CPU：50% 说明 CPU 有一半的时间在运行，一半的时间在休息（100MS 中50MS被进程占用，50MS处于空闲状态）</li></ul><h3 id="Q：如何让CPU使用率固定在50-【仅限于单核CPU】"><a href="#Q：如何让CPU使用率固定在50-【仅限于单核CPU】" class="headerlink" title="Q：如何让CPU使用率固定在50%【仅限于单核CPU】"></a>Q：如何让CPU使用率固定在50%【仅限于单核CPU】</h3><ul><li><p>CPU的占有率是由进程的忙和空闲来决定的，即 rate=(busy_time)/(busy_time+idle_time);</p></li><li><p>让CPU使用率固定在50%，只要让计算机有一半的时间在运行，一半的时间在休息就可以了。</p></li><li><p>busy可以用循环（这个循环用空循环，以便好控制），idle可以用sleep</p></li><li><p>比如先让任务管理器的cpu使用率始终保持在50%左右，那么在一个主循环中，让空循环和sleep运行同样的一小段时间。sleep的时间好搞，空循环的怎么办呢？可以在运行的时候设定空循环的运行时间</p><p><code>public</code> <code>static</code> <code>void</code> <code>main(String args[]) `</code>throws<code></code>InterruptedException{<code></code>int<code></code>busyTime = <code>10</code>;<code></code>int<code></code>idleTime = busyTime;<code></code>//设定空循环的运行时间<code></code>while<code>(</code>true<code>){</code> <code>long` `startTime = System.currentTimeMillis();</code> <code>//busy loop:</code> <code>while</code>((System.currentTimeMillis()-startTime)&lt;=busyTime)<code></code>;<code></code>Thread.sleep(idleTime);<code></code>}<code></code>}`</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器：</p><ul><li>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失</li><li>只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失</li><li>高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个读写速度比内存更快的存储器。当 CPU 向内存写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会直接从高速缓存中直接读取，当然，如需要的数据在Cache中没有，CPU会再去读取内存中的数据.</li></ul><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ul><li><p>操作系统的内存管理主要负责<strong>内存的分配与回收</strong>（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是<strong>将逻辑地址转换成相应的物理地址</strong>等功能也是操作系统内存管理做的事情</p></li><li><p>连续分配管理方式</p><p>：连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如</p><p>块式管理</p><ul><li><strong>块式管理</strong>：将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片</li></ul></li><li><p>非连续分配管理方式</p><p>：非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中</p><ul><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。<strong>页式管理通过页表对应逻辑地址和物理地址</strong></li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是<strong>段是有实际意义的，每个段定义了一组逻辑信息</strong>，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 <strong>段式管理通过段表对应逻辑地址和物理地址</strong></li><li><strong>段页式管理机制</strong> ：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是<strong>把主存先分成若干段，每个段又分成若干页</strong>，也就是说<strong>段页式管理机制中段与段之间以及段的内部的都是离散的</strong>。</li></ul></li></ul><h4 id="分页和分段共同点和区别"><a href="#分页和分段共同点和区别" class="headerlink" title="分页和分段共同点和区别"></a>分页和分段共同点和区别</h4><ul><li><p>共同点</p><p>：</p><ol><li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片</li><li><strong>页和段都是离散存储的</strong>，所以两者都是离散分配内存的方式。但是，<strong>每个页和段中的内存是连续的</strong></li></ol></li><li><p>分段和分页的不同</p><p>：</p><ol><li><strong>目的不同</strong>：<strong>分页是由于系统管理的需要</strong>而不是用户的需要，它是信息的物理单位；<strong>分段的目的是为了能更好地满足用户的需要</strong>，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li><li><strong>大小</strong>不同：<strong>页的大小固定且由系统决定</strong>；而<strong>段的长度却不固定，由其所完成的功能决定</strong>；</li><li>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li><li>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</li><li><strong>内存碎片</strong>：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li></ol></li></ul><h4 id="基本分页储存管理方式"><a href="#基本分页储存管理方式" class="headerlink" title="基本分页储存管理方式"></a>基本分页储存管理方式</h4><ul><li>在分页内存管理中，很重要的两点是：<strong>1. 虚拟地址到物理地址的转换要快【快表】；2. 解决虚拟地址空间大，页表也会很大的问题【多级分页】</strong></li><li>因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个<strong>页表来记录逻辑地址和实际存储地址之间的映射关系</strong>，<strong>以实现从页号到物理块号的映射</strong></li><li>由于页表也是存储在内存中的，因此访问分页系统中内存数据需要两次的内存访问【一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据】</li><li><strong>为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制</strong>，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中</li><li><strong>在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间</strong>。为了解决这个问题，可以采用<strong>两级页表或者多级页表的方法</strong></li><li>其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据</li></ul><h4 id="基本分段储存管理方式"><a href="#基本分段储存管理方式" class="headerlink" title="基本分段储存管理方式"></a>基本分段储存管理方式</h4><ul><li>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求【比如数据共享，数据保护，动态链接等】</li><li><strong>分段内存管理当中，地址是二维的，一维是段号，一维是段内地址</strong>；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</li><li>由于分段管理中，<strong>每个段内部是连续内存分配，但是段和段之间是离散分配的</strong>，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是<strong>段表机制</strong>。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。</li><li>访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了<a href="https://www.nowcoder.com/jump/super-jump/word?word=联想" target="_blank" rel="noopener">联想</a>寄存器。</li></ul><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><ul><li><p><strong>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享</strong></p></li><li><p>段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。</p></li><li><p>为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表（在一个进程中，段表只有一个，而页表可能有多个）</p></li><li><p>在进行地址变换时，<strong>首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址</strong>。如图所示，<strong>进行一次访问实际需要至少三次访问主存</strong>，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p></li><li><p>三次内存访问</p><p>：</p><ol><li>访问内存中的段表查到页表的起始地址</li><li>访问内存中的页表找到页帧号，形成物理地址</li><li>得到物理地址后，再一次访问内存，存取指令或者数据</li></ol></li></ul><h4 id="Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数"><a href="#Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数" class="headerlink" title="Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数"></a>Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数</h4><ul><li><p>页式存储（2次）</p><ol><li>访问内存中的页表，利用逻辑地址中的页号查找到页帧号，与逻辑地址中的页内偏移拼接形成物理地址；</li><li>得到物理地址后，再一次访问内存，存取指令或者数据。</li></ol></li><li><p><strong>段式存储（2次）</strong>：同页式存储</p></li><li><p>段页式存储（3次）</p><ol><li>访问内存中的段表查到页表的起始地址</li><li>访问内存中的页表找到页帧号，形成物理地址</li><li>得到物理地址后，再一次访问内存，存取指令或者数据</li></ol></li><li><p><strong>多级页表</strong>：若页表划分为N级，则需要访问内存N+1次。若系统有快表，则在快表命中时，只需访问1次内存即可</p></li><li><p>引入快表</p><p>：</p><ul><li>因为把页表放在内存中，至少需要访问两次内存才能存取一条指令或者数据（一次得到物理地址地址，一次存取），比较慢；因此在地址变换机构中增设了一个具有并行查找能力的高速缓冲寄存器—— 快表（全局只有一个，不在内存中！！！），用来存放当前访问的若干页表项（比较小，只能存放部分页表项）</li><li><strong>若快表命中</strong>，则可直接得到页帧号，与页内偏移拼接成物理地址后访问内存，进行指令或者数据的存取。（<strong>只需访问一次内存</strong>）</li><li><strong>若快表不命中</strong>，则需去内存中访问页表，形成物理地址后，再一次访问内存进行指令或者数据的存取。（需要访问两次内存）</li></ul></li></ul><h3 id="物理内存-amp-虚拟内存"><a href="#物理内存-amp-虚拟内存" class="headerlink" title="物理内存 &amp; 虚拟内存"></a>物理内存 &amp; 虚拟内存</h3><ul><li><p><strong>正在运行的一个进程，他所需的内存是有可能大于内存条容量之和</strong>的，比如你的<strong>内存条是256M，你的程序却要创建一个2G的数据区</strong>，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，在通过调度进入物理内存。所以，虚拟内存是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。有的地方呢，也叫这个虚拟内存为内存交换区。</p></li><li><p><strong>虚拟内存的作用就是，将需要大内存的分块，一块一块的递给物理内存</strong>。换言之，<strong>虚拟内存是通过页面调度实现的</strong></p></li><li><p>虚拟内存的目的是为了</p><p>让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p><p>。</p><ul><li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</li><li>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。</li><li>当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li></ul></li></ul><h4 id="进程的内存分配-amp-内存访问"><a href="#进程的内存分配-amp-内存访问" class="headerlink" title="进程的内存分配 &amp; 内存访问"></a>进程的内存分配 &amp; 内存访问</h4><ul><li><strong>进程是在虚拟内存中的</strong>，每个进程运行时都会得到4G的虚拟内存，得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换</li><li>进程内存访问<ol><li>每次要访问地址空间上的某一个地址，都需要<strong>把虚拟地址翻译为实际物理内存地址</strong></li><li><strong>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</strong></li><li>进程需要知道<strong>哪些地址空间上的数据在物理内存上</strong>，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过<strong>页表</strong>来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上（页面号），第二部分记录物理内存页的地址（偏移量）</li><li><strong>当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常</strong></li><li><strong>缺页异常</strong>的处理过程，<strong>操作系统立即阻塞该进程，并将硬盘里对应的页换入内存</strong>，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统选择的<strong>页面置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></strong></li></ol></li></ul><h4 id="虚拟内存置换算法"><a href="#虚拟内存置换算法" class="headerlink" title="虚拟内存置换算法"></a>虚拟内存置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></h4><ul><li><p>最佳(Optimal)置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></p><p>：</p><ul><li>一种理论<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>，无法实现，置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</li></ul></li><li><p>先进先出(FIFO)页面置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></p><p>：</p><ul><li>每次淘汰最早调入的页面。</li></ul></li><li><p>最近最久未使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>LRU</p><p>：</p><ul><li><a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。</li></ul></li><li><p>时钟<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>clock</p><p>(也被称为是</p><p>最近未使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>NRU</p><p>)：</p><ul><li>页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</li></ul></li><li><p>改进型Clock<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></p><p>：</p><ul><li>在Clock<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>的基础上添加一个修改位，替换时根据访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</li></ul></li><li><p>最少使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>LFU</p><p>：</p><ul><li>设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</li></ul></li></ul><h3 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态&amp;内核态"></a>用户态&amp;内核态</h3><ul><li><p>用户态：用户态运行的进程可以直接读取用户程序的数据</p></li><li><p>内核态：内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制</p></li><li><p>两者最重要的差别就在于<strong>特权级的不同</strong>，即权力的不同。<strong>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序</strong>。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态</p></li><li><p>用户态切换到内核态的3种方式</p><p>：</p><ol><li><strong>系统调用</strong>：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现</li><li><strong>异常</strong>：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</li><li><strong>外围设备的中断</strong>：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。（比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。）</li></ol></li></ul><h3 id="系统调度"><a href="#系统调度" class="headerlink" title="系统调度"></a>系统调度</h3><ul><li><p>Q：什么是系统调用</p><p>？</p><ul><li>我们运行的程序基本都是运行在用户态，如果需要调用操作系统提供的系统态级别的子功能，就需要系统调用。也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如<strong>文件管理、进程控制、内存管理</strong>等)，都必须<strong>通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</strong></li></ul></li><li><p>常见的系统调用：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能</li><li>文件管理。完成文件的读、写、创建及删除等功能</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能</li><li>进程通信。完成进程之间的消息传递或信号传递等功能</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能</li></ul></li></ul><h3 id="Q：Debug时看到的是物理内存还是虚拟内存-？"><a href="#Q：Debug时看到的是物理内存还是虚拟内存-？" class="headerlink" title="Q：Debug时看到的是物理内存还是虚拟内存 ？"></a>Q：Debug时看到的是物理内存还是虚拟内存 ？</h3><ul><li>虚拟内存，通常，<strong>在用户模式下，我们用调试器看到的内存地址都是虚拟内存</strong>。</li></ul><h2 id="操作系统是如何实现锁的？"><a href="#操作系统是如何实现锁的？" class="headerlink" title="操作系统是如何实现锁的？"></a>操作系统是如何实现锁的？</h2><ul><li><p>首先要搞清楚一个概念，<strong>在硬件层面，CPU提供了原子操作、关中断、锁内存总线的机制</strong>；<strong>OS基于这几个CPU硬件机制，就能够实现锁</strong>；再<strong>基于锁，就能够实现各种各样的同步机制</strong>（信号量、消息、Barrier等）</p></li><li><p>在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。</p></li><li><p><strong>锁机制的一个特点是它的同步原语都是原子操作</strong></p></li><li><p>那么操作系统是如何保证这些同步原语的原子性呢？</p><ul><li>操作系统之所以能构建锁之类的同步原语，是因为硬件已经为我们提供了一些原子操作，例如：</li></ul><ol><li>中断禁止和启用（interrupt enable/disable）</li><li>内存加载和存入（load/store）测试与设置（test and set）指令</li></ol></li><li><p>禁止中断这个操作是一个硬件步骤，中间无法插入别的操作。同样，中断启用，测试与设置均为一个硬件步骤的指令。在这些硬件原子操作之上，我们便可以构建软件原子操作：锁，睡觉与叫醒，信号量等。</p></li></ul><h3 id="操作系统使用锁的原语操作"><a href="#操作系统使用锁的原语操作" class="headerlink" title="操作系统使用锁的原语操作"></a>操作系统使用锁的原语操作</h3><ul><li><p>可以使用<strong>中断禁止，测试与设置</strong>两种<strong>硬件原语来实现软件的锁原语</strong>。这两种方式比较起来，显然<strong>测试与设置</strong>更加简单，也因此使用的<strong>更为普遍</strong>。此外，<strong>test and set还有一个优点，就是可以在多CPU环境下工作，而中断启用和禁止则不能</strong></p></li><li><p>使用中断启用与禁止来实现锁</p><p>：</p><ul><li>要防止一段代码在执行过程中被别的进程插入，就要考虑在一个单处理器上，一个线程在执行途中被切换的途径。我们知道，要切换进程，必须要发生上下文切换，上下文切换只有两种可能：</li></ul><ol><li><strong>一个线程自愿放弃CPU而将控制权交给操作系统调度器</strong>（<strong>通过yield之类的操作系统调用来实现</strong>）；</li><li><strong>一个线程被强制放弃CPU而失去控制权（通过中断来实现）</strong></li></ol><ul><li>原语执行过程中，我们不会自动放弃CPU控制权，因此<strong>要防止进程切换，就要在原语执行过程中不能发生中断。所以采用禁止中断</strong>，且不自动调用让出CPU的系统调用，就可以防止进程切换，将一组操作变为原子操作。</li><li>中断禁止：就是禁止打断，<strong>使用可以将一系列操作变为原子操作</strong></li><li>中断启用：就是从这里开始，可以被打断，允许操作系统进行调度</li><li>缺点：使用中断实现锁，繁忙等待，不可重入</li></ul></li><li><p>使用测试与设置指令来实现锁</p><ul><li>测试与设置（test &amp; set）指令：以不可分割的方式执行如下两个步骤：</li></ul><ol><li>设置操作：将1写入指定内存单元；</li><li>读取操作：返回指定内存单元里原来的值（写入1之前的值）</li></ol><ul><li>缺点：繁忙等待，不可重入</li></ul></li></ul><h3 id="操作系统中的锁机制"><a href="#操作系统中的锁机制" class="headerlink" title="操作系统中的锁机制"></a>操作系统中的锁机制</h3><ul><li><p><strong>互斥锁</strong>：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。只有取得互斥锁的进程才能进入临界区，无论读写，当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p></li><li><p>读写锁</p><p>：rwlock，分为读锁和写锁。读写锁要根据进程进入临界区的具体行为（读，写）来决定锁的占用情况。这样锁的状态就有三种了：读加锁、写加锁、无锁。</p><ol><li>无锁。读/写进程都可以进入；</li><li>读锁。读进程可以进入。写进程不可以进入；</li><li>写锁。读/写进程都不可以进入</li></ol></li><li><p>自旋锁</p><p>：spinlock，自旋锁是指在进程试图取得锁失败的时候选择忙等待而不是阻塞自己。</p><ul><li>选择忙等待的优点在于如果该进程在其自身的CPU时间片内拿到锁（说明锁占用时间都比较短），则相比阻塞少了上下文切换</li><li>注意这里还有一个隐藏条件：<strong>多处理器</strong>。因为单个处理器的情况下，由于当前自旋进程占用着CPU，持有锁的进程只有等待自旋进程耗尽CPU时间才有机会执行，这样CPU就空转了</li></ul></li><li><p>RCU</p><p>：read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，修改完成后，再将老数据update成新的数据。【有点像 copy-on-write】</p><ul><li>使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就<strong>不用考虑死锁问题</strong>了。</li><li>对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。</li><li>在有大量读操作，少量写操作的情况下效率非常高。【读多写少】</li></ul></li></ul><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul><li>早期计算机各个程序只能串行执行、系统资源利用低。为了解决上述问题，操作系统引入了中断机制，实现了<strong>多道程序的并发执行</strong>，提高了系统资源的利用率。</li><li><strong>中断是多程序并发执行的前提条件</strong></li></ul><ol><li>当一个时间片运行完后，CPU会接收到计时部件（操作系统内核的时钟管理部件）<strong>发出的中断信号，CPU立即进入核心态</strong>，把CPU的使用权限交还给操作系统</li><li>当中断发生后，当前运行的进程暂停运行，操作系统内核对中断进程处理，切换进程（根据进程调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>），在完成切换进程的一系列工作后，操作系统又会将CPU的使用权交还给用户进程</li><li>切换到的进程2拿到CPU执行权就会在用户态下执行</li></ol><ul><li>中断的<strong>本质</strong>：<strong>发生中断就意味着需要操作系统介入</strong>，开展管理工作</li></ul><h3 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h3><ol><li>执行完每个指令后，CPU都要检查当前是否有外部中断信号</li><li><strong>如果检测到外部中断信号，则需要保护被中断进程的CPU环境</strong>（<a href="https://www.nowcoder.com/jump/super-jump/word?word=如程" target="_blank" rel="noopener">如程</a>序状态字PSW、<strong>程序计数器、各种通用寄存器</strong>）</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol><h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><ul><li>中断可以分为：内中断和外中断</li><li>内中断：内中断的信号来源于CPU内部、与当前执行的指令有关。如整数除0</li><li>外中断：外中断的信号来源于CPU外部、与当前执行的指令无关。如用户强制结束一个进程、IO设备完成操作发生的中断信号</li></ul><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><ul><li>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</li><li>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：<ol><li>保护CPU现场</li><li>分析中断原因</li><li>转入缺页中断处理程序进行处理</li><li>恢复CPU现场，继续执行</li></ol></li><li>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：<ul><li>在指令执行期间产生和处理缺页中断信号</li><li>一条指令在执行期间，可能产生多次缺页中断</li><li>缺页中断返回的是，执行产生中断的一条指令，而一般的中断返回的是，执行下一条指令</li></ul></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="Q：操作系统临界资源的访问"><a href="#Q：操作系统临界资源的访问" class="headerlink" title="Q：操作系统临界资源的访问"></a>Q：操作系统临界资源的访问</h3><ul><li><strong>临界资源</strong>：<strong>一段时间内只允许一个线程访问的资源就称为临界资源或独占资源</strong></li><li><strong>临界区</strong>：对临界资源进行访问的那段代码称为临界区，通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</li><li><strong>多线程同步互斥的常见方法</strong>：</li></ul><ol><li><p><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 <strong>Java 中的 synchronized 关键词和各种 Lock 都是这种机制，本质是一个计数器</strong></p></li><li><p>信号量PV(Semphares)</p><p>：它</p><p>允许同一时刻多个线程来访问同一资源</p><p>，但是需要控制同一时刻访问此资源的最大线程数量【用来实现生产者消费者模型】</p><ul><li>信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</li><li>注意，<strong>信号量的值仅能由PV操作来改变</strong></li><li>p操作（wait）：申请一个单位资源，进程进入；v操作（signal）：释放一个单位资源，进程出来</li><li>PV操作的含义：<strong>PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作</strong></li></ul></li><li><p><strong>事件event</strong>：通过通知操作的方式来保持多线程同步，还可以方便实现多线程优先级的比较操作，Wait/Notify</p></li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul><li><p><strong>synchronized同步</strong>：本质上就是 “共享内存” 式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</p></li><li><p>while轮询的方式</p><p>：</p><ul><li>在这种方式下，ThreadA 不断地改变条件，ThreadB 不停地通过 while 语句检测这个条件比如说互斥量为0 是否成立 ，从而实现了线程间的通信。但是这种方式会浪费 CPU 资源。</li></ul></li><li><p>wait/notify机制</p><p>：</p><ul><li>当条件未满足时，ThreadA 调用 wait() 放弃 CPU，并进入阻塞状态。（不像 while 轮询那样占用 CPU）</li><li>当条件满足时，ThreadB 调用 notify() 通知线程 A，所谓通知线程 A，就是唤醒线程 A，并让它进入可运行状态</li></ul></li><li><p><strong>管道通信</strong>：java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</p></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>进程控制块 (Process Control Block，PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态</li><li><strong>就绪状态(ready)</strong>：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行</li><li><strong>运行状态(running)</strong> ：进程正在处理器上上运行（单核 CPU 下任意时刻只有一个进程处于运行状态）</li><li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行</li><li><p><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行</p></li><li><p><strong>只有就绪态和运行态可以相互转换，其它的都是单向转换</strong>。<strong>就绪状态</strong>的进程通过<strong>调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></strong>从而<strong>获得 CPU 时间，转为运行状态</strong>；而<strong>运行状态</strong>的进程，<strong>在分配给它的 CPU 时间片用完之后就会转为就绪状态</strong>，等待下一次调度。</p></li><li><p><strong>阻塞状态是缺少需要的资源从而由运行状态转换而来</strong>，<strong>但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态</strong></p></li><li><p>挂起</p><p>（换到外存）:</p><ul><li>挂起就绪：是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。</li></ul></li></ul><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ol><li><p>临界区：对临界资源进行访问的那段代码称为临界区。</p></li><li><p>同步与互斥：</p><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul></li><li><p>信号量</p><p>：信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作</li><li>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候<strong>屏蔽中断</strong></li><li>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量</strong>（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</li></ul></li><li><p>管程</p><p>：管程在功能上和信号量及PV操作类似，属于一种进程同步互斥工具，但是具有与信号量及PV操作不同的属性。</p><p>管程把控制的代码独立出来，封装了同步操作，对进程隐蔽了同步细节</p><p>，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。</p><ul><li>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li><li>管程引入了<strong>条件变量</strong>以及相关的操作：<strong>wait() 和 signal() 来实现同步操作</strong>。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li></ul></li></ol><h4 id="进程同步和进程通信的区别"><a href="#进程同步和进程通信的区别" class="headerlink" title="进程同步和进程通信的区别"></a>进程同步和进程通信的区别</h4><ul><li>进程同步：控制多个进程按一定顺序执行</li><li>进程通信：进程间传输信息</li><li>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息</li></ul><h3 id="Q：常见的进程间的通信方式（IPC，Inter-Process-Communication）？"><a href="#Q：常见的进程间的通信方式（IPC，Inter-Process-Communication）？" class="headerlink" title="Q：常见的进程间的通信方式（IPC，Inter-Process Communication）？"></a>Q：常见的进程间的通信方式（IPC，Inter-Process Communication）？</h3><ul><li><p>管道</p><p>：</p><p>管道可用于具有亲缘关系的父子进程间的通信</p><p>。linux 系统操作执行命令时，将一个程序的输出交给另一个程序进行处理。一个进程往管道输入数据，则会阻塞等待别的进程从管道读取数据。管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><ul><li>它具有以下限制：1. <strong>只支持半双工通信（单向交替传输）</strong>；2. <strong>只能在父子进程或者兄弟进程中使用</strong></li></ul></li><li><p><strong>命名管道（FIFO）</strong>：克服了管道没有名字的限制，<strong>具有管道所具有的功能外，还允许无亲缘关系进程间的通信</strong>，去除了管道只能在父子进程中使用的限制</p></li><li><p><strong>信号（singal）</strong>：<strong>信号是在软件层次上对中断机制的一种模拟</strong>，一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p></li><li><p>消息队列</p><p>：消息队列提供了从一个进程向另一个进程发送一个数据块的方法。</p><ul><li><strong>相比于命名管道的优点</strong>：<strong>消息队列可以独立于读写进程存在</strong>，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；<strong>避免了 FIFO 的同步阻塞问题</strong>，不需要进程自己提供同步方法；读进程可以<strong>根据消息类型有选择地接收消息</strong>，而不像 FIFO 那样只能默认地接收。</li><li><strong>缺点</strong>：使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间</li></ul></li><li><p>共享内存</p><p>：共享内存可以很好解决拷贝消耗的时间。</p><ul><li><strong>允许多个进程共享一个给定的存储区，不同进程可以及时看到对方进程中对共享内存中数据变更</strong>。因为数据不需要在进程之间复制，所以这是<strong>最快的一种 IPC</strong></li><li>共享内存需要依靠某种同步操作，如互斥锁和信号量等，<strong>需要使用信号量用来同步对共享存储的访问</strong>。</li><li>系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。可以让<strong>两个进程各自拿出一块虚拟地址空间，然后映射到相同的物理内存中</strong>，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了</li></ul></li><li><p>信号量（mutex）</p><p>：为了避免共享内存多进程竞争内存的问题（线程安全），使用信号量。</p><ul><li>信号量的<strong>本质就是一个计数器</strong>，用来<strong>实现进程之间的互斥与同步</strong>，<strong>用于为多个进程提供对共享数据对象的访问</strong>，信号量也是进程之间的一种通信方式。</li></ul></li><li><p><strong>Socket</strong>：Socket套接字进行通信，与其他机制不同的是，它<strong>可用于不同机器之间的进程间通信</strong>，应用非常广泛。</p></li></ul><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><p>一. <strong>批处理系统</strong></p><ul><li><p>批处理系统没有太多的用户操作，在该系统中，<strong>调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>目标是保证吞吐量和周转时间</strong>（从提交到终止的时间）</p></li><li><p>先来先服务调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></p><p>（FCFS）：</p><ul><li>每次调度是<strong>从就绪队列中选择一个最先进入该队列的进程</strong>，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</li><li>比较有利于长作业（进程），而不利于短作业（进程）</li><li><strong>有利于CPU繁忙型作业（进程） ，而不利于I/O繁忙型作业（进程）</strong></li><li>用于批处理系统，不适于分时系统</li></ul></li><li><p>短进程优先调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></p><p>：</p><ul><li><strong>从就绪队列中选出一个估计运行时间最短的进程</strong>，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</li><li>对长作业不利，未考虑作业(进程)的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li></ul></li><li><p>最短剩余时间优先</p></li></ul><p>shortest remaining time next（SRTN）</p><ul><li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li></ul><p>二. <strong>交互式系统</strong></p><ul><li><p>交互式系统有大量的用户交互操作，在该系统中调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>的目标是快速地进行响应</p></li><li><p>时间片轮转法</p><p>：</p><ul><li>系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，<strong>把CPU分配给队首进程，并令其执行一个时间片</strong>。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它<strong>送往就绪队列的末尾</strong>；然后，再把处理机分配给<strong>就绪队列中新的队首进程，同时也让它执行一个时间片</strong>。</li><li>紧迫任务响应慢。</li></ul></li><li><p>多级反馈队列调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></p><p>：</p><ol><li><strong>设置多个就绪队列</strong>，并为各个队列赋予不同的<strong>优先级</strong>；该<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>赋予<strong>各个队列中进程执行时间片</strong>的大小也各不相同，在<strong>优先权愈高</strong>的队列中，为<strong>每个进程所规定的执行时间片就愈小</strong>。</li><li>当一个新进程进入内存后，首先将它放入<strong>第一队列的末尾</strong>，<strong>按FCFS原则排队等待调度</strong>；当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；<strong>如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾</strong>，<strong>再同样地按FCFS原则等待调度执行</strong>；</li><li><strong>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行</strong></li></ol></li><li><p>优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></p><p>：</p><p>把处理机分配给就绪队列中优先权最高的进程</p><ul><li><strong>非抢占式优先权<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></strong>：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；</li><li><strong>抢占式优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></strong>：系统把处理机分配给优先权最高的进程，使之执行。但<strong>在其执行期间</strong>，<strong>只要出现了另一个其优先权更高的进程</strong>，<strong>进程调度程序就立即停止当前进程</strong>(原优先权最高的进程)的执行，<strong>重新将处理机分配给新到的优先权最高的进程</strong>。</li><li>这种抢占式的优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中</li></ul></li></ul><p>三. <strong>实时系统</strong></p><ul><li>实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</li></ul><h4 id="Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？"><a href="#Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？" class="headerlink" title="Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？"></a>Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？</h4><ul><li><strong>WARNING：这是我面试中遇到的问题，以下为我个人思考的答案，仅供参考</strong></li><li>可以采用<strong>多级反馈队列调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></strong>，可以看成时间片轮转调度和优先级调度的结合</li><li>最上面的队列，优先级最高，首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程</li><li><strong>如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾</strong>，若第二队列的时间片用完后作业还不能完成，一直进入下一级队列，直至完成</li><li>在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业即抢占式调度CPU</li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源</li><li>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换【一个进程有多个线程】</li><li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间，I/O 设备等，所付出的开销远大于创建或撤销线程时的开销；类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li>通信：线程间可以通过直接读写同一进程中的数据进行通信【线程共享进程内存空间】，但是进程通信需要借助 IPC</li></ul><h2 id="多进程-amp-多线程"><a href="#多进程-amp-多线程" class="headerlink" title="多进程 &amp; 多线程"></a>多进程 &amp; 多线程</h2><ul><li><p>进程</p><p>：</p><ul><li><strong>优点</strong>：1. 顺序程序的特点：具有封闭性和可再现性；2.<strong>程序的并发执行和资源共享</strong>。多道程序设计出现后，实现了程序的并发执行和资源共享，提高了系统的效率和系统的资源利用率。</li><li><strong>缺点</strong>：1. <strong>操作系统调度切换多个线程要比切换调度进程在速度上快的多</strong>。而且<strong>进程间内存无法共享</strong>，通讯也比较麻烦；2. 线程之间由于共享进程内存空间，所以交换数据非常方便；在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</li></ul></li><li><p>线程</p><p>：</p><ul><li><strong>优点</strong>：</li></ul><ol><li>启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间（因为在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段。<strong>线程之间却可以使用相同的地址空间，共享大部分数据</strong>）；</li><li><strong>线程间方便的通信机制</strong>，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便；</li><li>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上；</li></ol><ul><li><strong>缺点</strong>：<strong>调度时, 要保存线程状态</strong>，频繁调度, 需要占用大量的机时；程序设计上容易出错（<strong>线程同步问题</strong>）</li></ul></li><li><p>多进程</p><ul><li><strong>多进程优点</strong>：1. <strong>每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系</strong>；2. 通过增加CPU，就可以容易扩充性能；3. 可以<strong>尽量减少线程加锁/解锁的影响，极大提高性能</strong>，就算是线程运行的模块<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>效率低也没关系；4. 每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大。</li><li><strong>多进程缺点</strong>：1. 逻辑控制复杂，需要和主程序交互；2. 需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算；3. 多进程调度开销比较大。</li></ul></li><li><p>多线程</p><p>：</p><ul><li><strong>多线程的优点</strong>：1. 无需跨进程边界；2. 程序逻辑和控制方式简单；3. 所有线程可以直接共享内存和变量等；4. 线程方式消耗的总资源比进程方式好；</li><li><strong>多线程缺点</strong>：</li></ul><ol><li>每个线程与主程序共用地址空间，受限于2GB地址空间；</li><li><strong>线程之间的同步和加锁控制比较麻烦</strong>；</li><li>一个线程的崩溃可能影响到整个程序的稳定性；</li><li>到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数；</li><li><strong>线程能够提高的总性能有限</strong>，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU</li></ol></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li><p>进程/线程/协程区别</p><ul><li><strong>进程拥有自己独立的堆和栈</strong>，<strong>既不共享堆，亦不共享栈</strong>，进程<strong>由操作系统调度</strong></li><li><strong>线程拥有自己独立的栈</strong>和<strong>共享的堆</strong>，共享堆，不共享栈，<strong>线程亦由操作系统调度</strong></li><li><strong>协程</strong>和线程一样<strong>共享堆，不共享栈</strong>，协<strong>程由程序员在协程的代码里显示调度</strong></li></ul></li><li><p>协程与线程区别</p><p>：</p><ul><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU</li><li><strong>线程进程都是同步机制，而协程则是异步</strong></li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li><li><strong>协程避免了无意义的调度</strong>，由此可以提高性能，但也因此，<strong>程序员必须自己承担调度的责任</strong>，同时，<strong>协程也失去了标准线程使用多CPU的能力</strong></li></ul></li></ul><h3 id="Q：协程是如何更少占用资源的"><a href="#Q：协程是如何更少占用资源的" class="headerlink" title="Q：协程是如何更少占用资源的"></a>Q：协程是如何更少占用资源的</h3><ul><li>协程切换完全在用户空间进行，线程切换涉及用户态和内核态切换，需要在内核空间完成<ul><li>协程不依赖操作系统和其提供的线程</li><li><strong>协程之间的切换完全在用户态执行，在用户态没有时钟中断，系统调用等机制，因此效率高</strong>。<strong>协程切换只涉及基本的CPU上下文切换</strong>（寄存器保存 CPU运行任务所需要的信息），协程切换非常简单，就是把当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上。</li><li>系统内核调度的对象是线程，<strong>线程的调度只有拥有最高权限的内核空间才可以完成，所以线程的切换涉及到用户空间和内核空间的切换</strong>，现代操作系统一般都采用抢占式调度，<strong>上下文切换一般发生在时钟中断和系统调用返回前</strong>，调度器计算当前线程的时间片，如果需要切换就从运行队列中选出一个目标线程，保存当前线程的环境，并且恢复目标线程的运行环境。</li></ul></li><li>协程占用内存少<ul><li>线程除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等，上下文比协程多一些</li></ul></li></ul><h2 id="孤儿进程-amp-僵尸进程【怎么产生的？有什么危害？怎么去预防？】"><a href="#孤儿进程-amp-僵尸进程【怎么产生的？有什么危害？怎么去预防？】" class="headerlink" title="孤儿进程 &amp; 僵尸进程【怎么产生的？有什么危害？怎么去预防？】"></a>孤儿进程 &amp; 僵尸进程【怎么产生的？有什么危害？怎么去预防？】</h2><ul><li><p>一般进程，正常情况下：子进程由父进程创建，子进程再创建新的进程。父子进程是一个异步过程，父进程永远无法预测子进程的结束，所以，当子进程结束后，它的父进程会调用wait()或waitpid()取得子进程的终止状态，回收掉子进程的资源。</p></li><li><p><strong>孤儿进程</strong>：<strong>父进程结束了，而它的一个或多个子进程还在运行</strong>，那么这些子进程就成为孤儿进程(father died)。子进程的资源由init进程回收</p></li><li><p><strong>僵尸进程</strong>：<strong>子进程退出了，但是父进程没有用wait或waitpid去获取子进程的状态信息，子进程的进程描述符仍然保存在系统中</strong></p></li><li><p>危害</p><p>：</p><ul><li>如果父进程不调用wait或waitpid的话，那么保留的信息就不会被释放，其进程号就会被一直占用，但是系统所能使用的进程号是有限的，如果大量产生僵死进程，<strong>将因没有可用的进程号而导致系统无法产生新的进程</strong>，这就是僵尸进程的危害</li><li>孤儿进程是没有父进程的进程，它由init进程循环的wait()回收资源，init进程充当父进程。因此孤儿进程并没有什么危害</li></ul></li><li><p>预防/解决方法</p><p>：</p><ul><li>fork()两次，将子进程变成孤儿进程，从而其父进程变成init进程，通过init进程处理僵尸进程【fork函数的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程】</li><li>通过信号机制，在处理函数中调用wait，回收资源</li></ul></li></ul><h3 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步 &amp; 异步"></a>同步 &amp; 异步</h3><ul><li><p>同步需要等待（阻塞），异步无需等待（不阻塞）</p></li><li><p>同步</p><p>：可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令</p><ul><li>同步就是整个处理过程<strong>顺序执行</strong>，当各个过程都执行完毕，并返回结果。是一种<strong>线性执行的方式</strong>，<strong>执行的流程不能跨越</strong>。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统。</li></ul></li><li><p>异步</p><p>：执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程</p><ul><li><strong>异步</strong>则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕，而是继续执行下面的流程。<strong>是一种并行处理的方式</strong>，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页</li></ul></li></ul><h2 id="操作系统中的堆栈"><a href="#操作系统中的堆栈" class="headerlink" title="操作系统中的堆栈"></a>操作系统中的堆栈</h2><ul><li><p><strong>操作系统的堆和栈是指对内存进行操作和管理的一些方式</strong>这和数据结构中的堆和栈是有区别的</p></li><li><p>栈</p><p>：</p><ul><li>栈也可以称之为栈内存是一个具有动态内存区域，存储函数内部（包括main函数）的局部变量，方法调用及函数参数值</li><li><strong>由编译器/系统自动分配和释放</strong>。例如，声明在函数中一个局部变量，即int b，系统自动在栈中为变量b开辟空间</li><li>栈存放<strong>函数的参数值，局部变量的值</strong>等。其操作方式类似于数据结构中的栈，满足：“先进后出”的原则存取，也就是位于栈内的元素，必须等到其上面（对应的地址为较低的地址）的数据或函数执行完成后，弹出后才可以进行下面的元素的操作</li><li>栈是由系统自动分配的，一般速度较快（<strong>栈的速度高于堆的速度</strong>）</li><li>申请大小的限制：栈是向低地址扩展的，是一块连续的内存的区域。栈顶的地址和栈的最大容量<strong>是系统预先规定好的</strong>，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ，<strong>如果申请的空间超过栈的剩余空间时，将提示overflow</strong>。因此，<strong>能从栈获得的空间较小</strong>。</li></ul></li><li><p>堆</p><p>：</p><ul><li>一般由程序员分配释放，并指明大小，堆被程序申请使用的内存在被主动释放前一直有效。堆需要由由程序员手动释放，<strong>不及时回收容易产生内存泄露</strong>。 程序结束时可能由操作系统回收。</li><li>栈是存放在一级缓存中的，而堆则是存放在二级缓存中的，<strong>堆的生命周期由虚拟机的垃圾回收<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>来决定</strong>（并不是一旦成为孤儿对象就能被回收），所以调用这些对象的速度要相对来得低一些，故堆的速度慢于栈的速度</li><li>与数据结构中的堆是不同的，分配方式类似于<a href="https://www.nowcoder.com/jump/super-jump/word?word=链表" target="_blank" rel="noopener">链表</a>（空闲<a href="https://www.nowcoder.com/jump/super-jump/word?word=链表" target="_blank" rel="noopener">链表</a>法），<strong>堆是向高地址扩展的数据结构，是不连续的内存区域</strong>，这是由于系统是用<a href="https://www.nowcoder.com/jump/super-jump/word?word=链表" target="_blank" rel="noopener">链表</a>来存储空闲内存地址的，自然是不连续的，而<a href="https://www.nowcoder.com/jump/super-jump/word?word=链表" target="_blank" rel="noopener">链表</a>的遍历方向是由低地址向高地址。<strong>堆的大小受限于计算机系统中有效的虚拟内存</strong>。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li><p>区别</p><p>：</p><ul><li>空间分配：栈由操作系统自动分配释放；堆一般由程序员分配释放</li><li>申请效率对比：栈使用一级缓存，被调用时通常处于存储空间中，调用后被立即释放；.堆使用二级缓存，生命周期与虚拟机的GC<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>有关，调用速度相对较低。</li><li>申请大小的限制：栈是向低地址扩展的数据结构，是一块连续的内存的区域；堆是向高地址扩展的数据结构，是不连续的内存区域</li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><a href="https://juejin.im/post/5c37577e6fb9a049fd100da8#heading-0" target="_blank" rel="noopener">参考文章</a></p><ul><li>死锁是指<strong>多个进程</strong>在运行过程中因<strong>争夺资源</strong>而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进</li></ul><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ul><li><strong>多个进程竞争资源</strong></li><li><strong>进程间推进顺序不当</strong></li></ul><h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul><li><strong>互斥</strong>条件，在任何时刻一个资源只能被一个进程使用</li><li><strong>拥有和请求</strong>（请求和保持条件），已经得到某个资源的进程可以再请求新的资源</li><li><strong>不可抢占</strong>（不剥夺条件），已经分配给进程的资源不能被抢占，而只能被显式释放</li><li><strong>循环等待</strong>（环路等待条件），系统中有两个或多个的进程组成一条循环，该循环中的每个进程都等待着另一个进程占有的资源</li></ul><h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><ol><li><p>解决死锁：【<strong>撤销进程法</strong>】</p></li><li><p>死锁预防</p><p>：破坏死锁产生的四个必要条件中的一个或多个，以避免发生死锁。【资源有序分配法】</p><ul><li>破坏互斥：不让资源被一个进程独占，可通过假脱机技术允许多个进程同时访问资源；</li><li>破坏拥有和请求：1. 已拥有资源的进程不能再去请求其他资源，要求进程在开始执行前请求需要的所有资源；2. 要求进程请求资源时，先暂时释放其当前拥有的所有资源，再尝试一次获取所需的全部资源</li><li>破坏不可抢占：有些资源可以通过虚拟化方式实现可抢占</li><li>破坏循环等待：1. 保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，必须先释放第一个资源；是将所有资源进行统一编号，进程可以在任何时刻请求资源，但要求进程必须按照顺序请求资源</li></ul></li><li><p><strong>避免死锁</strong>：判断是否会出现死锁就是看是否能找到一个安全序列，使得进程按推进顺序为每个进程分配其所需资源，使每个进程都能顺序执行。例如：【<strong>银行家<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></strong>】</p></li><li><p><strong>检测死锁并恢复</strong>：资源分配图；从一个或多个进程中抢占资源分配给死锁进程；终止所有的死锁进程。【<strong>资源分配图化简法</strong>】</p></li></ol><h3 id="如何发现死锁？"><a href="#如何发现死锁？" class="headerlink" title="如何发现死锁？"></a>如何发现死锁？</h3><ul><li>通过死锁检测工具，例如通过jdk工具jps、jstack排查死锁问题</li></ul><ol><li><strong>使用jsp查找程序进行</strong>：jps是jdk提供的一个工具，可以查看到正在运行的java进程</li><li><strong>使用jstack查看线程堆栈信息</strong>：jstack：jdk提供的一个工具，可以查看java进程中线程堆栈信息，后面可以查看到具体在代码哪一行。</li><li>也通过jdk提供的工具<strong>jconsole排查死锁问题</strong>：jconsole是<strong>jdk提供的一个可视化的工具</strong>，方便排查程序的一些问题，如：程序内存溢出、死锁问题等等。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;[toc]&lt;/p&gt;&lt;h2 id=&quot;操作系统的四大特性&quot;&gt;&lt;a href=&quot;#操作系统的四大特性&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="操作系统" scheme="https://lincx_py.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记1</title>
    <link href="https://lincx_py.gitee.io/2020/12/20/operation-system-2/"/>
    <id>https://lincx_py.gitee.io/2020/12/20/operation-system-2/</id>
    <published>2020-12-20T08:36:20.000Z</published>
    <updated>2020-12-21T15:34:27.918Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>计算机体系结构/内存层次</p><ul><li>计算机体系结构</li><li>内存层次</li><li>操作系统的内存管理方式</li></ul><p>计算机体系结构与内存管理</p><ul><li><p>重定位</p></li><li><p>分段</p></li><li><p>分页</p></li><li><p>段页式</p></li></ul><h2 id="三个连续内存分配算法"><a href="#三个连续内存分配算法" class="headerlink" title="三个连续内存分配算法"></a>三个连续内存分配算法</h2><ol><li><p>最先匹配算法</p><ul><li><p>原理&amp;实现</p><ul><li><p>空闲分区列表按地址顺序排序</p></li><li><p>分配过程时，搜索一个合适的分区</p></li><li><p>释放分区时，检查是否可与临近的空闲分区合并</p></li></ul></li><li><p>优点</p><ul><li><p>简单</p></li><li><p>在高地址空间有大块的空闲分区</p></li></ul></li><li><p>缺点</p><ul><li>外部碎片</li><li>分配大块时较慢</li></ul></li></ul></li><li><p>最佳匹配算法</p><ul><li>原理&amp;实现<ul><li>空闲分区列表按照由小到大排序</li><li>分配时，查找一个合适的分区（第一个比它大的分区）</li><li>释放时，查找并且合并临近的空闲分区（如果能够找得到）（临近指的是地址临近）</li></ul></li><li>优点<ul><li>大部分分配的尺寸较小时，效果很好</li><li>可避免大的空闲分区被拆分</li><li>可减少外补碎片的大小</li><li>相对简单</li></ul></li><li>缺点<ul><li>外部碎片</li><li>释放分区较慢</li><li>容易产生很多无用的小碎片</li></ul></li></ul></li><li><p>最差匹配算法</p><ul><li>原理&amp;实现<ul><li>空闲分区列表按由大到小排序</li><li>分配时，选最大的分区</li><li>释放时，检察是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序</li></ul></li><li>优点<ul><li>中等大小的分配较多时，效果较好</li><li>避免出现太多的小碎片</li></ul></li><li>缺点<ul><li>释放分区较慢</li><li>外部碎片</li><li>容易破环大的空闲分区，因此后续难以分配较大的分区</li></ul></li></ul></li></ol><h2 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h2><h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><p>段的概念</p><ul><li>段表示访问方式和存储数据等属性相同的一段相同地址空间</li><li>每个段对应一个连续内存”块”</li><li>若干个段组成进程的逻辑地址空间</li></ul><p>段地址=段号+段内地址偏移</p><p>页式存储管理</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://lincx_py.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="os" scheme="https://lincx_py.gitee.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>一、操作系统概述</title>
    <link href="https://lincx_py.gitee.io/2020/12/19/operation-system-1/"/>
    <id>https://lincx_py.gitee.io/2020/12/19/operation-system-1/</id>
    <published>2020-12-19T07:45:36.000Z</published>
    <updated>2020-12-19T10:26:06.197Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="1、操作系统定义"><a href="#1、操作系统定义" class="headerlink" title="1、操作系统定义"></a>1、操作系统定义</h2><p>操作系统是一个控制程序</p><p>操作系统是一个资源管理器</p><ul><li>应用程序与硬件之间的中间层</li><li>管理各种计算机软硬件资源</li><li>提供访问计算机软硬件资源的高效手段</li><li>解决资源访问冲突，确保资源公平使用</li></ul><h3 id="操作系统的地位"><a href="#操作系统的地位" class="headerlink" title="操作系统的地位"></a>操作系统的地位</h3><p><a href="https://imgchr.com/i/rNo0xA" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/19/rNo0xA.png" alt="rNo0xA.png"></a></p><p>操作系统是系统软件</p><p><a href="https://imgchr.com/i/rNo6Vf" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/19/rNo6Vf.png" alt="rNo6Vf.png"></a></p><p>操作系统内核</p><p><a href="https://imgchr.com/i/rNoca8" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/19/rNoca8.png" alt="rNoca8.png"></a></p><h2 id="操作系统内核特征"><a href="#操作系统内核特征" class="headerlink" title="操作系统内核特征"></a>操作系统内核特征</h2><ol><li><p><strong>并发</strong><br>计算机系统同时存在多个运行的程序，需要OS管理和调用</p></li><li><p><strong>共享</strong></p><ul><li>“同时”享用</li><li>互斥共享</li></ul></li><li><p><strong>虚拟</strong><br>利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务</p></li><li><p><strong>异步</strong></p></li></ol><h2 id="操作系统的演变"><a href="#操作系统的演变" class="headerlink" title="操作系统的演变"></a>操作系统的演变</h2><ul><li>单用户系统</li><li>批处理系统</li><li>多程序系统</li><li>分时</li><li>个人计算机：单个用户单个系统</li><li>分布式计算：多个用户多个系统</li></ul><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p><a href="https://imgchr.com/i/rNo7ZV" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/19/rNo7ZV.png" alt="rNo7ZV.png"></a></p><p><a href="https://imgchr.com/i/rNobIU" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/19/rNobIU.png" alt="rNobIU.png"></a></p><p><a href="https://imgchr.com/i/rNTCdK" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/19/rNTCdK.png" alt="rNTCdK.png"></a></p><p><a href="https://imgchr.com/i/rNTkJe" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/19/rNTkJe.png" alt="rNTkJe.png"></a></p><h1 id="启动、中断、异常和系统调用"><a href="#启动、中断、异常和系统调用" class="headerlink" title="启动、中断、异常和系统调用"></a>启动、中断、异常和系统调用</h1><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>BIOS(“Basic Input Output System”),<strong>其实，它是一组固化到**</strong><a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a><strong><strong>内</strong></strong><a href="https://baike.baidu.com/item/主板" target="_blank" rel="noopener">主板</a><strong><strong>上一个</strong></strong><a href="https://baike.baidu.com/item/ROM" target="_blank" rel="noopener">ROM</a><strong><strong><a href="https://baike.baidu.com/item/芯片" target="_blank" rel="noopener">芯片</a></strong></strong>上的<strong><strong><a href="https://baike.baidu.com/item/程序" target="_blank" rel="noopener">程序</a></strong></strong>，它保存着<strong><strong>计算机</strong></strong>最重要的基本输入输出的程序<strong><strong>、开机后自检程序和系统自启动程序，它可从</strong></strong><a href="https://baike.baidu.com/item/CMOS/428167" target="_blank" rel="noopener">CMOS</a><strong><strong>中读写</strong></strong>系统设置<strong>**的具体信息</strong>。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。此外，BIOS还向作业系统提供一些系统参数。系统硬件的变化是由BIOS隐藏，程序使用BIOS功能而不是直接控制硬件。现代作业系统会忽略BIOS提供的抽象层并直接控制硬件组件。</p><h3 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h3><p><a href="https://imgchr.com/i/rNTEzd" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/19/rNTEzd.png" alt="rNTEzd.png"></a></p><h3 id="操作系统用户态与内核态"><a href="#操作系统用户态与内核态" class="headerlink" title="操作系统用户态与内核态"></a>操作系统用户态与内核态</h3><p>内核态（Kernel Mode）：又称管态，运行操作系统程序，操作硬件</p><p>用户态（User Mode）：运行用户程序</p><h3 id="用户态与内核态的转换"><a href="#用户态与内核态的转换" class="headerlink" title="用户态与内核态的转换"></a>用户态与内核态的转换</h3><p><strong>从用户态到内核态切换可以通过三种方式</strong>：</p><ol><li><strong>系统调用</strong>，应用程序一般无法直接访问硬件，也无法执行特权指令。所以，需要通过操作系统来间接完成相关的工作。而基于安全和可靠性的需求，应用程序运行在用户态，操作系统内核运行在内核态，导致应用程序无法通过函数调用来访问操作系统提供的各种服务，于是通过系统调用的方式就成了应用程序向OS发出请求并获得服务反馈的唯一通道和接口。</li><li><strong>异常</strong>：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。</li><li><strong>外设中断</strong>：当外设完成用户的请求时，会向CPU发送中断信号。中断是异步产生的，会随时打断应用程序的执行，且在操作系统的管理之下，应用程序感知不到中断的产生。所以操作系统需要保存被打断的应用程序的执行现场，处理具体的中断，然后恢复被打断的应用程序的执行现场，使得应用程序可以继续执行。</li></ol><p><strong>从内核态到用户态的转换：</strong></p><p>程序状态字（PSW）寄存器用于记录当前处理器的状态和控制指令的执行顺序，并且保留与运行程序相关的各种信息，主要作用是实现程序状态的保护和恢复。所以中断处理程序要将PSW保存，子程序调用在进程内部执行，不会更改PSW。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;操作系统概述&quot;&gt;&lt;a href=&quot;#操作系统概述&quot; class=&quot;headerlink&quot; title=&quot;操作系统概述&quot;&gt;&lt;/a&gt;操作系
      
    
    </summary>
    
      <category term="操作系统" scheme="https://lincx_py.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="os" scheme="https://lincx_py.gitee.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>go-swagger</title>
    <link href="https://lincx_py.gitee.io/2020/12/18/go-swagger/"/>
    <id>https://lincx_py.gitee.io/2020/12/18/go-swagger/</id>
    <published>2020-12-18T11:39:41.000Z</published>
    <updated>2020-12-18T12:54:14.944Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><h1 id="gin-swagger-配置及使用"><a href="#gin-swagger-配置及使用" class="headerlink" title="gin-swagger 配置及使用"></a>gin-swagger 配置及使用</h1><p>在学习java springboot的时候接触过swagger这个自动生成API的工具，但是那时候是整合到springboot的，然后现在接触比较多点的是gin这个框架，所以想在gin也使用这个工具自动生成API</p><h2 id="关于swaggo"><a href="#关于swaggo" class="headerlink" title="关于swaggo"></a>关于swaggo</h2><p>或许你使用过<a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a>, 而 swaggo就是代替了你手动编写yaml的部分。只要通过一个命令就可以将注释转换成文档，这让我们可以更加专注于代码。</p><p>目前swaggo主要实现了swagger 2.0 的以下部分功能：</p><ul><li><p>基本结构（Basic Structure）</p></li><li><p>API 地址与基本路径（API Host and Base Path）</p></li><li><p>路径与操作 （Paths and Operations）</p></li><li><p>参数描述（Describing Parameters）</p></li><li><p>请求参数描述（Describing Request Body）</p></li><li><p>返回描述（Describing Responses）</p></li><li><p>MIME 类型（MIME Types）</p></li><li><p>认证（Authentication）</p><ul><li>Basic Authentication</li><li>API Keys</li></ul></li><li><p>添加实例（Adding Examples）</p></li><li><p>文件上传（File Upload）</p></li><li><p>枚举（Enums）</p></li><li><p>按标签分组（Grouping Operations With Tags）</p></li><li><p>扩展（Swagger Extensions）</p></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1、使用swaggo首先需要安装<code>swag cli</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure><p>2、还需要安装两个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">gin-swagger 中间件</span></span><br><span class="line">go get github.com/swaggo/gin-swagger</span><br><span class="line"><span class="meta">#</span><span class="bash"> swagger内置文件</span></span><br><span class="line">go get github.com/swaggo/gin-swagger/swaggerFiles</span><br></pre></td></tr></table></figure><p>3、安装成功后，可以通过<code>swag --version</code>查看安装版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ swag --version</span><br><span class="line">swag version v1.7.0</span><br></pre></td></tr></table></figure><p>如果出现 <code>swag: command not found</code>(Linux)</p><p>则编辑<code>vim ~./bashrc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/go #根据你的主机gopath路径改</span><br><span class="line">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>或者 windows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swag : 无法将“nodemon”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路</span><br><span class="line">径正确，然后再试一次。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ swag --version</span><br><span class="line">+ ~~~~~~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (nodemon:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br></pre></td></tr></table></figure><p>则在环境变量中的系统变量新建一条</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[gopath]\bin</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加注释</p><h3 id="main函数中添加"><a href="#main函数中添加" class="headerlink" title="main函数中添加"></a>main函数中添加</h3><p>在<code>main.go</code>文件中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">        ginSwagger <span class="string">"github.com/swaggo/gin-swagger"</span></span><br><span class="line">        <span class="string">"github.com/swaggo/gin-swagger/swaggerFiles"</span></span><br><span class="line">        _ <span class="string">"swaggerdemo/docs"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// @title Swagger Example API</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @description This is a sample server celler server.</span></span><br><span class="line"><span class="comment">// @termsOfService https://razeen.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @contact.name Razeen</span></span><br><span class="line"><span class="comment">// @contact.url https://razeen.me</span></span><br><span class="line"><span class="comment">// @contact.email me@razeen.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @license.name Apache 2.0</span></span><br><span class="line"><span class="comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @host 127.0.0.1:8080</span></span><br><span class="line"><span class="comment">// @BasePath /api/v1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r := gin.Default()</span><br><span class="line">        r.GET(<span class="string">"/swagger/*any"</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line">        v1 := r.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                v1.GET(<span class="string">"/hello"</span>, HandleHello)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，添加注释。其中：</p><ul><li><code>titile</code>: 文档标题</li><li><code>version</code>: 版本</li><li><code>description,termsOfService,contact ...</code> 这些都是一些声明，可不写。</li><li><code>license.name</code> 这是必须要写的。</li><li><code>host</code>,<code>BasePath</code>: 如果你想直接swagger调试API，这两项需要填写正确。前者为服务文档的端口，ip。后者为基础路径，像我这里就是“/api/v1”。</li><li>在原文档中还有<code>securityDefinitions.basic</code>,<code>securityDefinitions.apikey</code>等，这些都是用来做认证的，我这里暂不展开。</li></ul><p>然后，在与<code>main.go</code>同目录下执行swag init 可以自动生成文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  swaggerdemo swag init</span><br><span class="line">2020/12/18 20:38:49 Generate swagger docs....</span><br><span class="line">2020/12/18 20:38:49 Generate general API Info, search dir:./</span><br><span class="line">2020/12/18 20:39:00 create docs.go at docs/docs.go</span><br><span class="line">2020/12/18 20:39:00 create swagger.json at docs/swagger.json</span><br><span class="line">2020/12/18 20:39:00 create swagger.yaml at docs/swagger.yaml</span><br></pre></td></tr></table></figure><p>运行项目<code>go run main.go</code></p><p>浏览器打开<a href="http://127.0.0.1:8080/swagger/index.html" target="_blank" rel="noopener">http://127.0.0.1:8080/swagger/index.html</a>, 我们可以看到如下文档标题已经生成。</p><p><a href="https://imgchr.com/i/rYHhGQ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/18/rYHhGQ.png" alt="rYHhGQ.png"></a></p><h3 id="Handle函数中添加"><a href="#Handle函数中添加" class="headerlink" title="Handle函数中添加"></a>Handle函数中添加</h3><p>在每个路由的处理函数上边添加注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Summary 测试SayHello</span></span><br><span class="line"><span class="comment">// @Description 向你说Hello</span></span><br><span class="line"><span class="comment">// @Tags 测试</span></span><br><span class="line"><span class="comment">// @Accept mpfd</span></span><br><span class="line"><span class="comment">// @Produce json</span></span><br><span class="line"><span class="comment">// @Param who query string true "人名"</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;string&#125; string "&#123;"msg": "hello Razeen"&#125;"</span></span><br><span class="line"><span class="comment">// @Failure 400 &#123;string&#125; string "&#123;"msg": "who are you"&#125;"</span></span><br><span class="line"><span class="comment">// @Router /hello [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleHello</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">who := c.Query(<span class="string">"who"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> who == <span class="string">""</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"who are u?"</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"hello "</span> + who&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，每次添加结束都需要<code>swag init</code>，重新生成新的文件</p><p>再运行 <code>go run main.go</code></p><p><a href="https://imgchr.com/i/rYbnsI" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/18/rYbnsI.md.png" alt="rYbnsI.md.png"></a></p><h5 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h5><p>Tags 是用来给API分组的。</p><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p>接收的参数类型，支持表单(<code>mpfd</code>) , JSON(<code>json</code>)等，更多如下表。</p><h5 id="Produce"><a href="#Produce" class="headerlink" title="Produce"></a>Produce</h5><p>返回的数据结构，一般都是<code>json</code>, 其他支持如下表：</p><table><thead><tr><th style="text-align:left">Mime Type</th><th style="text-align:left">声明</th></tr></thead><tbody><tr><td style="text-align:left">application/json</td><td style="text-align:left">json</td></tr><tr><td style="text-align:left">text/xml</td><td style="text-align:left">xml</td></tr><tr><td style="text-align:left">text/plain</td><td style="text-align:left">plain</td></tr><tr><td style="text-align:left">html</td><td style="text-align:left">html</td></tr><tr><td style="text-align:left">multipart/form-data</td><td style="text-align:left">mpfd</td></tr><tr><td style="text-align:left">application/x-www-form-urlencoded</td><td style="text-align:left">x-www-form-urlencoded</td></tr><tr><td style="text-align:left">application/vnd.api+json</td><td style="text-align:left">json-api</td></tr><tr><td style="text-align:left">application/x-json-stream</td><td style="text-align:left">json-stream</td></tr><tr><td style="text-align:left">application/octet-stream</td><td style="text-align:left">octet-stream</td></tr><tr><td style="text-align:left">image/png</td><td style="text-align:left">png</td></tr><tr><td style="text-align:left">image/jpeg</td><td style="text-align:left">jpeg</td></tr><tr><td style="text-align:left">image/gif</td><td style="text-align:left">gif</td></tr></tbody></table><h5 id="Param"><a href="#Param" class="headerlink" title="Param"></a>Param</h5><p>参数，从前往后分别是：</p><blockquote><p>@Param who query string true “人名”</p><p>@Param <code>1.参数名</code> <code>2.参数类型</code> <code>3.参数数据类型</code> <code>4.是否必须</code> <code>5.参数描述</code> <code>6.其他属性</code></p></blockquote><ul><li><p>1.参数名</p><p>参数名就是我们解释参数的名字。</p></li><li><p>2.参数类型</p><p>参数类型主要有四种：</p><ul><li><p><code>path</code> 该类型参数直接拼接在URL中，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleGetFile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param id path integer true &quot;文件ID&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>query</code> 该类型参数一般是组合在URL中的，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleHello</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param who query string true &quot;人名&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>formData</code> 该类型参数一般是<code>POST,PUT</code>方法所用，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleLogin</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param user formData string true &quot;用户名&quot; default(admin)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>body</code> 当<code>Accept</code>是<code>JSON</code>格式时，我们使用该字段指定接收的JSON类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param param body main.JSONParams true &quot;需要上传的JSON&quot;</span><br></pre></td></tr></table></figure></li><li><p>3.参数数据类型</p><p>数据类型主要支持一下几种：</p><ul><li>string (string)</li><li>integer (int, uint, uint32, uint64)</li><li>number (float32)</li><li>boolean (bool)</li></ul><p>注意，如果你是上传文件可以使用<code>file</code>, 但参数类型一定是<code>formData</code>, 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param file formData file true &quot;文件&quot;</span><br></pre></td></tr></table></figure></li><li><p>4.是否是必须</p><p>表明该参数是否是必须需要的，必须的在文档中会黑体标出，测试时必须填写。</p></li><li><p>5.参数描述</p><p>就是参数的一些说明</p></li><li><p>6.其他属性</p><p>除了上面这些属性外，我们还可以为该参数填写一些额外的属性，如枚举，默认值，值范围等。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">枚举</span><br><span class="line">// @Param enumstring query string false &quot;string enums&quot; Enums(A, B, C)</span><br><span class="line">// @Param enumint query int false &quot;int enums&quot; Enums(1, 2, 3)</span><br><span class="line">// @Param enumnumber query number false &quot;int enums&quot; Enums(1.1, 1.2, 1.3)</span><br><span class="line"></span><br><span class="line">值添加范围</span><br><span class="line">// @Param string query string false &quot;string valid&quot; minlength(5) maxlength(10)</span><br><span class="line">// @Param int query int false &quot;int valid&quot; mininum(1) maxinum(10)</span><br><span class="line"></span><br><span class="line">设置默认值</span><br><span class="line">// @Param default query string false &quot;string default&quot; default(A)</span><br></pre></td></tr></table></figure><p>而且这些参数是可以组合使用的，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param enumstring query string false &quot;string enums&quot; Enums(A, B, C) default(A)</span><br></pre></td></tr></table></figure></li></ul><h5 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h5><p>指定成功响应的数据。格式为：</p><blockquote><p>// @Success <code>1.HTTP响应码</code> <code>{2.响应参数类型}</code> <code>3.响应数据类型</code> <code>4.其他描述</code></p></blockquote><ul><li><p>1.HTTP响应码</p><p>也就是200，400，500那些。</p></li><li><p>2.响应参数类型 / 3.响应数据类型</p><p>返回的数据类型，可以是自定义类型，可以是json。</p><ul><li>自定义类型</li></ul><p>在平常的使用中，我都会返回一些指定的模型序列化JSON的数据，这时，就可以这么写：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Success 200 &#123;object&#125; main.File</span><br></pre></td></tr></table></figure><p>其中，模型直接用<code>包名.模型</code>即可。你会说，假如我返回模型数组怎么办？这时你可以这么写：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Success 200 &#123;anrry&#125; main.File</span><br></pre></td></tr></table></figure><ul><li>json</li></ul><p>将如你只是返回其他的数据格式可如下写：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Success 200 &#123;string&#125; string &quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>4.其他描述</p><p>可以添加一些说明。</p></li></ul><h5 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h5><p>同Success。</p><h5 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h5><p>指定路由与HTTP方法。格式为：</p><blockquote><p>// @Router <code>/path/to/handle</code> [<code>HTTP方法</code>]</p></blockquote><p>不用加基础路径哦。</p><h3 id="生成文档与测试"><a href="#生成文档与测试" class="headerlink" title="生成文档与测试"></a>生成文档与测试</h3><p>其实上面已经穿插的介绍了。</p><p>在<code>main.go</code>下运行<code>swag init</code>即可生成和更新文档。</p><p>点击文档中的<code>Try it out</code>即可测试。 如果部分API需要登陆，可以Try登陆接口即可。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>看到这里，基本可以使用了。但文档一般只是我们测试的时候需要，当我的产品上线后，接口文档是不应该给用户的，而且带有接口文档的包也会大很多（swaggo是直接build到二进制里的）。</p><p>想要处理这种情况，我们可以在编译的时候优化一下，如利用<code>build tag</code>来控制是否编译文档。</p><p>在<code>main.go</code>声明<code>swagHandler</code>,并在该参数不为空时才加入路由：</p><p>在<code>main.go</code>声明<code>swagHandler</code>,并在该参数不为空时才加入路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line">var swagHandler gin.HandlerFunc</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    if swagHandler != nil &#123;</span><br><span class="line">r.GET(&quot;/swagger/*any&quot;, swagHandler)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时,我们将该参数在另外加了<code>build tag</code>的包中初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// +build doc</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">_ &quot;github.com/razeencheng/demo-go/swaggo-gin/docs&quot;</span><br><span class="line"></span><br><span class="line">ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="line">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">swagHandler = ginSwagger.WrapHandler(swaggerFiles.Handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就可以使用<code>go build -tags &quot;doc&quot;</code>来打包带文档的包，直接<code>go build</code>来打包不带文档的包。</p><p>你会发现，即使我这么小的Demo,编译后的大小也要相差19M !</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  swaggo-gin git:(master) ✗ go build</span><br><span class="line">➜  swaggo-gin git:(master) ✗ ll swaggo-gin</span><br><span class="line">-rwxr-xr-x  1 xxx  staff    15M Jan 13 00:23 swaggo-gin</span><br><span class="line">➜  swaggo-gin git:(master) ✗ go build -tags &quot;doc&quot;</span><br><span class="line">➜  swaggo-gin git:(master) ✗ ll swaggo-gin</span><br><span class="line">-rwxr-xr-x  1 xxx  staff    34M Jan 13 00:24 swaggo-gin</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;gin-swagger-配置及使用&quot;&gt;&lt;a href=&quot;#gin-swagger-配置及使用&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="swagger" scheme="https://lincx_py.gitee.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker的Flask项目部署</title>
    <link href="https://lincx_py.gitee.io/2020/12/13/flask-deploy/"/>
    <id>https://lincx_py.gitee.io/2020/12/13/flask-deploy/</id>
    <published>2020-12-13T10:00:14.000Z</published>
    <updated>2020-12-14T07:10:25.598Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><h1 id="基于Docker的Flask项目部署"><a href="#基于Docker的Flask项目部署" class="headerlink" title="基于Docker的Flask项目部署"></a>基于Docker的Flask项目部署</h1><p>最近使用flask框架完成了一个项目，准备部署到服务器上边，捣鼓了几天，终于搞定了，回来写一下部署心得体会。</p><h2 id="为什么选择docker"><a href="#为什么选择docker" class="headerlink" title="为什么选择docker"></a>为什么选择docker</h2><blockquote><p>将软件打包成标准化单元，用于开发，装运和部署</p><p>容器是一个标准的软件单元，它将代码及其所有的依赖关系打包，以便应用程序从计算环境快速可靠地运行到另外一个计算环境。Docker容器映像是一个轻量级，独立地可执行软件包，包含运行应用程序所需地一切：代码，运行时，系统工具，系统库和设置。</p><p>容器映像在运行时成为容器，在Docker容器的情况下——映像在Docker Engine上运行时成为容器。适用于基于Linux和Windows的应用程序，无论基础架构如何，容器化软件都将始终运行相同。容器将软件与其环境隔离开来，并确保它可以统一运行，尽管开发和分段之间存在差异。</p><p>个人使用体验：自从接触了docker我就一直使用docker部署自己的项目以及一些其他东西（例如：Mysql、Redis等），在本地主机中配合wsl使用，体验简直完美。一般我都会在本地先将自己的项目打包成镜像，在本地测试，能正常工作后，就将它镜像上传到阿里云镜像站或者腾讯云镜像站，然后再在服务器使用docker拉取，然后运行，部署简单，一次打包，多处部署。</p></blockquote><h2 id="关于Flask部署的一些坑"><a href="#关于Flask部署的一些坑" class="headerlink" title="关于Flask部署的一些坑"></a>关于Flask部署的一些坑</h2><p>因为是第一次接触这个框架，所以对部署有点陌生，以为它也可以跟golang的项目那样，编译成一个二进制可执行文件，然后再使用Alpine这类轻量级的Linux镜像进行部署。</p><p>但是flask开发文档说，在开发时，你可以使用内置的服务器，但是其自带服务器的处理能力比较有限。默认情况下一次只能处理一个请求，当然你也可以设置为多进程或者多线程的情况。但是在生产环境 下你就应当选择功能完整的服务器。Werkzeug的WSGI服务器不适合在生产环境中使用。在开发过程中作为便利提供。它没有考虑到安全性或性能（默认情况下一次只处理一个请求）。使用真正的WSGI应用程序服务器（如uWSGI或Gunicorn）来提高性能，并通过真正的Web服务器（如Nginx）进行代理，以提高性能和安全性。 Web服务器擅长于排队请求/响应，可以同时提供静态和其他内容，并被设计为处理SSL。 WSGI服务器能够有效协调整个应用程序的多个请求。 Werkzeug被设计成WSGI库，而不是Web服务器或WSGI服务器。</p><p>总而言之，Flask应用是一个符合WSGI规范的Python应用，不能独立运行（类似app.run的方式仅适合开发模式），需要依赖其他的组件提供服务器功能。</p><h3 id="服务器的选择"><a href="#服务器的选择" class="headerlink" title="服务器的选择"></a>服务器的选择</h3><ul><li><p><strong>Gunicorn</strong></p><p><a href="http://gunicorn.org/" target="_blank" rel="noopener">Gunicorn</a> 是一个给 UNIX 用的 WSGI HTTP 服务器。这是一个从 Ruby 的 Unicorn 项目移植的 pre-fork worker 模式。它既支持 <a href="http://eventlet.net/" target="_blank" rel="noopener">eventlet</a> ，也 支持 <a href="http://codespeak.net/py/0.9.2/greenlet.html" target="_blank" rel="noopener">greenlet</a> 。在这个服务器上运行 Flask 应用是相当简单的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn myproject:app</span><br></pre></td></tr></table></figure><p><a href="http://gunicorn.org/" target="_blank" rel="noopener">Gunicorn</a> 提供了许多命令行选项 —— 见 <code>gunicorn -h</code> 。 例如，用四个 worker 进程（ <code>gunicorn -h</code> ）来运行一个 Flask 应用，绑定 到 localhost 的4000 端口（ <code>-b 127.0.0.1:4000</code> ）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w 4 -b 127.0.0.1:4000 myproject:app</span><br></pre></td></tr></table></figure></li><li><p><strong>Gevent</strong></p><p><a href="http://www.gevent.org/" target="_blank" rel="noopener">Gevent</a> 是一个基于协同程序的 Python 网络库，使用 <a href="http://codespeak.net/py/0.9.2/greenlet.html" target="_blank" rel="noopener">greenlet</a> 来在 <a href="http://monkey.org/~provos/libevent/" target="_blank" rel="noopener">libevent</a> 的事件循环上提供高层的同步 API</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent.wsgi <span class="keyword">import</span> WSGIServer</span><br><span class="line"><span class="keyword">from</span> yourapplication <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line">http_server = WSGIServer((<span class="string">''</span>, <span class="number">5000</span>), app)</span><br><span class="line">http_server.serve_forever()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>uWSGI</strong><br>uWSGI 也是部署 Flask 的途径之一,类似的部署途径还有 <a href="http://nginx.org/" target="_blank" rel="noopener">nginx</a> 、 <a href="http://www.lighttpd.net/" target="_blank" rel="noopener">lighttpd</a> 和 <a href="http://www.cherokee-project.com/" target="_blank" rel="noopener">cherokee</a> 。其他部署途径的信息参见 <a href="http://www.pythondoc.com/flask/deploying/fastcgi.html#deploying-fastcgi" target="_blank" rel="noopener"><em>FastCGI</em></a> 和 <a href="http://www.pythondoc.com/flask/deploying/wsgi-standalone.html#deploying-wsgi-standalone" target="_blank" rel="noopener"><em>独立 WSGI 容器</em></a> 。使用 uWSGI 协议来部署 WSGI 应用的先决条件是 需要一个 uWSGI 服务器。 uWSGI 既是一个协议也是一个服务器。如果作为一个服务器， 它可以服务于 uWSGI 、 FastCGI 和 HTTP 协议。</p><p>最流行的 uWSGI 服务器是 <a href="http://projects.unbit.it/uwsgi/" target="_blank" rel="noopener">uwsgi</a> ，本文将使用它来举例，请先安装它。</p><p>注意：</p><blockquote><p>请务必把 <code>app.run()</code> 放在 <code>if __name__ == &#39;__main__&#39;:</code> 内部或者放在单独 的文件中，这样可以保证它不会被调用。因为，每调用一次就会开启一个本地 WSGI 服务器。当我们使用 uWSGI 部署应用时，不需要使用本地服务器。</p></blockquote><p>​ 使用 uwsgi 启动你的应用<a href="http://www.pythondoc.com/flask/deploying/uwsgi.html#id1" target="_blank" rel="noopener">¶</a></p><p>uwsgi 是基于 python 模块中的 WSGI 调用的。假设 Flask 应用名称为 myapp.py ， 可以使用以下命令：</p><p><code>$ uwsgi -s /tmp/uwsgi.sock --module myapp --callable ap</code></p><p>或者这个命令也行：</p><p><code>$ uwsgi -s /tmp/uwsgi.sock -w myapp:app</code></p></li></ul><p>考虑到gunicorn能实现并发操作，就选用gunicorn作为项目的服务器，然后因为Linux会今至绑定1024以下的端口，所以部署的时候使用到Nginx进行代理转发</p><h3 id="gunicorn的安装与使用"><a href="#gunicorn的安装与使用" class="headerlink" title="gunicorn的安装与使用"></a>gunicorn的安装与使用</h3><p><strong>安装方式可使用pip安装</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install gunicorn gevent</span><br></pre></td></tr></table></figure><p>安装之后如果运行<code>gunicorn 命令</code>出现 <code>common not found</code>，则将pip3的包路径添加到环境变量中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜   pip3 show gunicorn</span><br><span class="line">Name: gunicorn</span><br><span class="line">Version: 20.0.4</span><br><span class="line">Summary: WSGI HTTP Server for UNIX</span><br><span class="line">Home-page: http://gunicorn.org</span><br><span class="line">Author: Benoit Chesneau</span><br><span class="line">Author-email: benoitc@e-engura.com</span><br><span class="line">License: MIT</span><br><span class="line">Location: /home/lincx/.local/lib/python3.8/site-packages</span><br><span class="line">Requires: setuptools</span><br><span class="line">Required-by:</span><br><span class="line">➜   vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在bashrc文件末尾添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/lincx/.local/bin</span><br></pre></td></tr></table></figure><p>此处根据你的机器显示的路径修改将/lib/xxx更换成/bin</p><p>运行命令</p><p>简单地，gunicorn可以通过<code>gunicorn -w 4 -b 127.0.0.1:4000 run:app</code>启动一个Flask应用。其中,</p><ul><li><code>-w 4</code>是指预定义的工作进程数为4，</li><li><code>-b 127.0.0.1:4000</code>指绑定地址和端口</li><li>run是flask的启动python文件，app则是flask应用程序实例</li></ul><p>通过<code>gunicorn -h</code>可以看到gunicorn的所有配置项，通常部署项目会写一个配置文件进行配置，如下，gunicorn.conf.py为一个配置文件，内容为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gunicorn.conf.py</span></span><br><span class="line">workers = <span class="number">5</span></span><br><span class="line">worker_class = <span class="string">"gevent"</span></span><br><span class="line">bind = <span class="string">"0.0.0.0:8087"</span></span><br></pre></td></tr></table></figure><p>运行项目命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  gunicorn app:app -c gunicorn.conf.py</span><br></pre></td></tr></table></figure><p>接下来，</p><h3 id="将项目打包成镜像"><a href="#将项目打包成镜像" class="headerlink" title="将项目打包成镜像"></a><strong>将项目打包成镜像</strong></h3><p>在这里，我踩了一个坑，为了追求镜像的简洁，我当初想到的方案是，使用Alpine作为基础镜像，然后在这个基础上边配置python3 环境，再将flask项目copy 到镜像中，运行</p><p>想法是美好的，现实是残酷的。Alpine 不支持Matplotlib、Numpy、Pandas这类数据科学计算相关的库安装，编译的时候会报错，起初我以为是python版本的原因，所以尝试配置了各种版本的python，但是结果都差不多，折腾了好久</p><blockquote><p>这是怎么搞的？如果你仔细看上面基于Ubuntu的构建，你会发现它下载三方库的安装包是matplotlib-3.1.2-cp38-cp38-manylinux1_x86_64.whl，这是一个预编译的二进制安装包。而Alpine则只能下载源代码（matplotlib-3.1.2.tar.gz）的压缩包，这就是Alpine的致命问题：标准的Linux安装包在Alpine Linux上根本无法使用。</p><p>大多数Linux发行版都使用GNU版本的标准C库（glibc），几乎所有基于C语言的脚本语言都需要这个库，包括Python。但Alpine Linux使用的是musl，那些二进制安装包是针对glibc编译的，因此Alpine禁用了Linux安装包支持。现在大多数Python包都在PyPI上包含了二进制安装包，大大加快了安装时间。但是如果你使用的是Alpine Linux，你需要编译你使用的每一个Python包中的所有C源码。</p></blockquote><p><strong>解决方案</strong></p><p>将基础镜像换成ubuntu，在本地环境，如果你只是想“玩一玩”，那么基础镜像选择Alpine无可厚非，但是如果你想要将你的python应用部署到生产环境时，特别是部署分布式系统需要多次编译的场景下，选择老牌的Ubuntu显然更加的明智。</p><h4 id="制作python环境的ubuntu镜像"><a href="#制作python环境的ubuntu镜像" class="headerlink" title="制作python环境的ubuntu镜像"></a>制作python环境的ubuntu镜像</h4><p>为了提高这个镜像的重用性，方便以后部署python相关的项目，我先制作了一个配置好python环境的ubuntu镜像</p><ol><li>首先编写dockerfile</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This hack is widely applied to avoid python printing issues in docker containers.</span></span><br><span class="line"><span class="comment"># See: https://github.com/Docker-Hub-frolvlad/docker-alpine-python3/pull/13</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update -y &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get install -y python3-pip python3-dev</span></span><br></pre></td></tr></table></figure><ol start="2"><li>运行构建镜像命令 <code>docker build -t ubuntu-flask:1.0 .</code><br>命令说明：</li></ol><ul><li>build : docker创建镜像的命令</li><li>-t ，-tag： 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li>ubuntu-flask:1.0 ：镜像名字以及版本号</li></ul><p>​ 注意要加上<strong><code>.</code></strong></p><p>​ 运行<code>docker images</code>可看到容器创建成功</p><p><a href="https://imgchr.com/i/rm0f4U" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/rm0f4U.md.png" alt="rm0f4U.md.png"></a></p><h4 id="基于ubuntu-flask镜像创建项目的镜像"><a href="#基于ubuntu-flask镜像创建项目的镜像" class="headerlink" title="基于ubuntu_flask镜像创建项目的镜像"></a>基于ubuntu_flask镜像创建项目的镜像</h4><p>1、首先，cd进入项目目录，将项目中用到的模块，导出至requirements.txt文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>2、在当前目录下编写dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu_flask:<span class="number">1.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list<span class="comment">#更换apt下载源</span></span></span><br><span class="line"><span class="bash">RUN sed -i s@/security.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list<span class="comment">#更换apt下载源</span></span></span><br><span class="line"><span class="bash"><span class="comment">#将当前文件夹下面的requirements.txt复制到容器中</span></span></span><br><span class="line"><span class="bash">COPY ./requirements.txt /requirements.txt</span></span><br><span class="line"><span class="bash"><span class="comment">#根目录为工作目录</span></span></span><br><span class="line"><span class="bash">WORKDIR /</span></span><br><span class="line"><span class="bash"><span class="comment">#安装依赖</span></span></span><br><span class="line"><span class="bash">RUN pip3 install -r requirements.txt</span></span><br><span class="line"><span class="bash"><span class="comment">#将当前目录下的文件拷贝至容器根目录</span></span></span><br><span class="line"><span class="bash">COPY . /</span></span><br><span class="line"><span class="bash"><span class="comment">#执行命令</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"gunicorn"</span>, <span class="string">"app:app"</span>, <span class="string">"-c"</span>, <span class="string">"./gunicorn.conf.py"</span>]</span></span><br></pre></td></tr></table></figure><p>3、创建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ubun-flask-st .</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/rmD8eI" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/rmD8eI.md.png" alt="rmD8eI.md.png"></a></p><p>4、运行容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8087:8087 --name stapp ubun-flask-st:latest</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/rny1DH" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/14/rny1DH.md.png" alt="rny1DH.md.png"></a></p><p>5、测试结果</p><p>6、成功！</p><p>7、打包镜像，发布到阿里云镜像站或者腾讯云镜像站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜   sudo docker login --username=xxxxxx registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">[sudo] password for lincx:</span><br><span class="line">Password:</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">➜   sudo docker tag [镜像id] registry.cn-shenzhen.aliyuncs.com/xxxxx/stapp:1.0</span><br><span class="line">➜   sudo docker push registry.cn-shenzhen.aliyuncs.com/xxxx/stapp:1.0</span><br></pre></td></tr></table></figure><p>8、到此，本地工作结束</p><h3 id="腾讯云服务器部署"><a href="#腾讯云服务器部署" class="headerlink" title="腾讯云服务器部署"></a>腾讯云服务器部署</h3><p>前提条件：安装了docker</p><p>登录服务器</p><p>到这里，工作就很简单了，只需要几个操作</p><p>1、登录阿里镜像站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜   sudo docker login --username=xxxxxx registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">[sudo] password for lincx:</span><br><span class="line">Password:</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><p>2、拉取项目镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push registry.cn-shenzhen.aliyuncs.com/xxxx/stapp:1.0</span><br></pre></td></tr></table></figure><p>3、运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8087:8087 --name stapp ubun-flask-st:latest</span><br></pre></td></tr></table></figure><p>4、使用nginx做反向代理，这里我也是用docker搭配nginx做的，详情请看<a href="https://lincx_py.gitee.io/2020/12/13/deploy/">这篇文章</a></p><p>5、在第4步基础上，编辑nginx的conf文件，添加下面内容至<code>server{}</code>中</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /st/ &#123;</span><br><span class="line">       <span class="comment">#proxy_set_header X-Real-IP $remote_addr;</span></span><br><span class="line">       <span class="comment">#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span></span><br><span class="line">       <span class="comment">#proxy_set_header Host  $http_host;</span></span><br><span class="line">       <span class="comment">#proxy_set_header X-Nginx-Proxy true;</span></span><br><span class="line">       <span class="comment">#proxy_set_header Connection "";</span></span><br><span class="line">       <span class="comment">#proxy_pass      http://xxxxxx:8087/;#这里填服务器的ip</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>6、测试结果：</p><p><a href="https://imgchr.com/i/rmyZoq" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/14/rmyZoq.jpg" alt="rmyZoq.jpg"></a></p><p>成功！！！！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;基于Docker的Flask项目部署&quot;&gt;&lt;a href=&quot;#基于Docker的Flask项目部署&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="python" scheme="https://lincx_py.gitee.io/categories/python/"/>
    
    
      <category term="flask" scheme="https://lincx_py.gitee.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>docker配合服务器配置https协议</title>
    <link href="https://lincx_py.gitee.io/2020/12/13/deploy/"/>
    <id>https://lincx_py.gitee.io/2020/12/13/deploy/</id>
    <published>2020-12-13T08:39:20.000Z</published>
    <updated>2020-12-13T09:56:17.825Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="服务器配置HTTPS全过程"><a href="#服务器配置HTTPS全过程" class="headerlink" title="服务器配置HTTPS全过程"></a>服务器配置HTTPS全过程</h1><h1 id="使用nginx为服务器配置HTTPS全过程"><a href="#使用nginx为服务器配置HTTPS全过程" class="headerlink" title="使用nginx为服务器配置HTTPS全过程"></a>使用nginx为服务器配置HTTPS全过程</h1><p>HTTPS，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>配置HTTPS就需要证书，关于证书方面不做过多解释，只介绍大概情况 ：<br>证书通过权威的CA机构付费获得的证书才能被互联网承认，我们将其放在服务器上面，配置好后，就可以进行https通信了。<br>可以打开百度，在地址前可以看到安全两个字，可以点击查看百度的服务器证书。</p><p><a href="https://imgchr.com/i/reWw26" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/reWw26.md.png" alt="reWw26.md.png"></a></p><p>当然也可以自己给自己发一个证书，也可以进行https通信，但是如果用浏览器访问的话，会提示不安全。毕竟我们不是权威。（此方法本文不介绍）</p><h2 id="Https协议验证过程"><a href="#Https协议验证过程" class="headerlink" title="Https协议验证过程"></a>Https协议验证过程</h2><p>https验证过程是分为单向验证和双向验证</p><h3 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h3><p>1、 客户端保存着服务端的证书并信任该证书即可(参照百度，咱们是没有证书的，百度的证书是由权威CA机构颁布的)</p><p>2、https一般是单向认证，这样可以让绝大部分人都可以访问你的站点。(依旧参照百度，这里咱们只需要验证百度的服务器证书即可，这里是浏览器去验证的)</p><h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>1、先决条件是有两个或两个以上的证书，一个是服务端证书，另一个或多个是客户端证书。</p><p>2、服务端保存着客户端的证书并信任该证书，客户端保存着服务端的证书并信任该证书。这样，在证书验证成功的情况下即可完成请求响应。(只有服务器验证客户端证书并通过，客户端验证服务器证书并通过，才可以进行通信，否则不可以！)</p><p>3、双向认证一般企业应用对接。(所以企业与企业间对接，大部分都是自签证书)<br><img src="https://img-blog.csdn.net/20180809143731312?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmJj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>总结：单向验证只需要客户端验证服务器证书即可，双向则需要双方都验证，才可以进行通信！</p><p>（此部分转载自<a href="https://blog.csdn.net/csdn_bbc/article/details/81536865）" target="_blank" rel="noopener">https://blog.csdn.net/csdn_bbc/article/details/81536865）</a></p><h2 id="证书制作"><a href="#证书制作" class="headerlink" title="证书制作"></a>证书制作</h2><p>本人使用的是腾讯云服务器，域名也是在腾讯买的，所以就直接在腾讯云申请了ssl证书</p><p><a href="https://imgchr.com/i/refYy8" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/refYy8.md.png" alt="refYy8.md.png"></a></p><p>登录腾讯云官网–&gt;总览–&gt;SSL证书</p><p><a href="https://imgchr.com/i/ref76K" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/ref76K.md.png" alt="ref76K.md.png"></a></p><p>免费证书的有效时间为1年</p><p><a href="https://imgchr.com/i/refvtA" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/refvtA.md.png" alt="refvtA.md.png"></a></p><p>之后按照这个流程填写资料，填完后提交</p><p><a href="https://imgchr.com/i/rebHXR" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/rebHXR.md.png" alt="rebHXR.md.png"></a></p><p>然后等待一两分钟就可以在ssl证书的主页看到新产生的证书了</p><p><a href="https://imgchr.com/i/rehc9I" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/rehc9I.md.png" alt="rehc9I.md.png"></a></p><p>点击下载，即可得到一个压缩包文件，解压之后可得到四个文件夹，里边都是对应的两个证书文件</p><p><a href="https://imgchr.com/i/rehIEQ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/13/rehIEQ.png" alt="rehIEQ.png"></a></p><h2 id="docker-amp-nginx配置https协议"><a href="#docker-amp-nginx配置https协议" class="headerlink" title="docker&amp;nginx配置https协议"></a>docker&amp;nginx配置https协议</h2><p>对docker的认识程度为0的朋友，可以离开了</p><p>关于docker的使用，大家可以先到百度了解一下它的使用，这里也不细讲了.</p><h3 id="docker制作nginx镜像"><a href="#docker制作nginx镜像" class="headerlink" title="docker制作nginx镜像"></a>docker制作nginx镜像</h3><p>本地使用ssh登录腾讯云主机，注意腾讯云服务器已经安装了docker</p><p>1、拉取nginx镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull nginx</span><br></pre></td></tr></table></figure><p>2、在宿主机器中创建nginx的挂载文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/nginx/conf ~/nginx/logs ~/nginx/www ~/nginx/certs</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><p>mkdir -p :linux创建文件夹的命令</p></li><li><p>~/:用户目录</p></li><li><p>conf文件夹：用来存放nginx的配置文件</p></li><li><p>logs文件夹：存放nginx产生的日志文件</p></li><li><p>www文件夹：存放html index静态文件</p></li></ul><p>3、获取一个默认的nginx.conf配置文件，通过创建一个临时的nginx容器，将配置文件拷贝至~/nginx/conf/中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm --name nginx-test -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><p>–rm：容器终止运行后，自动删除容器文件。</p></li><li><p>-p 8080:80： 将容器的 80 端口映射到主机的 8080 端口.</p></li><li><p>-d ：容器后台运行</p></li><li>–name ：容器命名</li><li>nginx ：镜像名字</li></ul><p>将配置文件拷贝至~/nginx/conf/中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker cp [nginx-test容器的ID]:/etc/nginx/nginx.conf ~/nginx/conf/</span><br></pre></td></tr></table></figure><p>终止容器运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stop [nginx-test容器的ID]</span><br></pre></td></tr></table></figure><p>4、将下载的证书文件上传至服务器的 ~/nginx/certs/中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [文件名] [用户名]@[服务器ip地址]：~/nginx/certs/</span><br></pre></td></tr></table></figure><p>5、编辑nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cd  ~/nginx/conf</span><br><span class="line"><span class="meta">#</span> vim nginx.conf</span><br></pre></td></tr></table></figure><p>将内容更换为一下内容</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">   <span class="attribute">server_name</span> www.xxxx.xxx; <span class="comment">#填写绑定证书的域名</span></span><br><span class="line">   <span class="attribute">ssl_certificate</span> certs/xxxxxxxx.crt;<span class="comment">#换成证书名字</span></span><br><span class="line">   <span class="attribute">ssl_certificate_key</span> certs/xxx.key;<span class="comment">#换成证书名字</span></span><br><span class="line">   <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">   <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>; <span class="comment">#按照这个协议配置</span></span><br><span class="line">   <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<span class="comment">#按照这个套件配置</span></span><br><span class="line">   <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">   <span class="attribute">location</span> / &#123;</span><br><span class="line">       <span class="comment">#proxy_set_header X-Real-IP $remote_addr;</span></span><br><span class="line">       <span class="comment">#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span></span><br><span class="line">       <span class="comment">#proxy_set_header Host  $http_host;</span></span><br><span class="line">       <span class="comment">#proxy_set_header X-Nginx-Proxy true;</span></span><br><span class="line">       <span class="comment">#proxy_set_header Connection "";</span></span><br><span class="line">       <span class="comment">#proxy_pass      http://xxxxxx:8080/;</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#server&#123;</span></span><br><span class="line"><span class="comment">#   listen 80;</span></span><br><span class="line"><span class="comment">#    server_name www.stana.top;</span></span><br><span class="line"><span class="comment">#    return 301 https://$host$request_uri;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、部署命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 443:443 --name nginx-py \</span><br><span class="line">  -v /home/ubuntu/nginx/www:/usr/share/nginx/html \</span><br><span class="line">  -v /home/ubuntu/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">  -v /home/ubuntu/nginx/certs:/etc/nginx/certs \</span><br><span class="line">  -v /home/ubuntu/nginx/logs:/var/log/nginx \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li>–rm：容器终止运行后，自动删除容器文件。</li><li>-p 8081:80： 将容器的 443 端口映射到主机的 443 端口.</li><li>–name nginx-py：将容器命名为 nginx-py</li><li>-v /home/ubuntu/nginx/www:/usr/share/nginx/html：将我们自己创建的 www 目录挂载到容器的 /usr/share/nginx/html。</li><li>-v /home/ubuntu/nginx/conf/nginx.conf:/etc/nginx/nginx.conf：将我们自己创建的 nginx.conf 挂载到容器的 /etc/nginx/nginx.conf。</li><li>-v /home/ubuntu/nginx/logs:/var/log/nginx：将我们自己创建的 logs 挂载到容器的 /var/log/nginx。</li></ul><p>到此部署完成！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;服务器配置HTTPS全过程&quot;&gt;&lt;a href=&quot;#服务器配置HTTPS全过程&quot; class=&quot;headerlink&quot; title=&quot;服
      
    
    </summary>
    
      <category term="docker" scheme="https://lincx_py.gitee.io/categories/docker/"/>
    
    
      <category term="nginx" scheme="https://lincx_py.gitee.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记1</title>
    <link href="https://lincx_py.gitee.io/2020/12/09/java-0/"/>
    <id>https://lincx_py.gitee.io/2020/12/09/java-0/</id>
    <published>2020-12-09T04:57:28.000Z</published>
    <updated>2020-12-09T05:38:04.266Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="Java多线程入门"><a href="#Java多线程入门" class="headerlink" title="Java多线程入门"></a>Java多线程入门</h1><h2 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h2><h3 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h3><p>一个正在执行的程序就是一个进程，系统会为这个进程分配资源</p><h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><p>具体执行任务的最小单位 ，一个进程中至少有一个线程。</p><h4 id="2-1-进程与线程之间的联系"><a href="#2-1-进程与线程之间的联系" class="headerlink" title="2.1 进程与线程之间的联系"></a>2.1 进程与线程之间的联系</h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">关系</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">一个进程最少拥有一个线程–主线程— 运行起来就执行的线程</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">线程之间可以共享资源（这个内存资源是由进程申请的）</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">线程之间可以进行通信（数据传输：多数为主线程与子线程）</td></tr></tbody></table><h4 id="2-2-创建线程的方法（两种）"><a href="#2-2-创建线程的方法（两种）" class="headerlink" title="2.2 创建线程的方法（两种）"></a>2.2 创建线程的方法（两种）</h4><h5 id="2-2-1继承Thread类实现run方法"><a href="#2-2-1继承Thread类实现run方法" class="headerlink" title="2.2.1继承Thread类实现run方法"></a>2.2.1继承Thread类实现run方法</h5><font color="red">步骤</font><ol><li><p>定义类继承Thread</p></li><li><p>重写Thread类的run方法；</p></li><li>调用线程的start方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.UseThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> MyTask().run();</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"通过继承实现的多线程！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-实现Runnable接口"><a href="#2-2-2-实现Runnable接口" class="headerlink" title="2.2.2 实现Runnable接口"></a>2.2.2 实现Runnable接口</h5><p><strong>注意事项</strong>：接口应该由哪些打算通过某一线程执行其实例的类来实现。类必须定义一个称为run的无参方法。</p><font color="red">步骤</font><ol><li>创建任务： 创建类实现Runnable接口</li><li>使用Thread 为这个任务分配线程</li><li>开启任 务 Start()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.UseThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"通过接口实现多线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-线程的生命周期"><a href="#2-3-线程的生命周期" class="headerlink" title="2.3 线程的生命周期"></a>2.3 线程的生命周期</h3><p>一个线程的生命周期中，总共有以下6种状态</p><ul><li><strong>NEW</strong> - 这个状态主要是线程未被Thread.start()调用前的状态。</li><li><strong>RUNNABLE</strong> - 线程正在JVM中被执行，它可能正在等待来自操作系统(如处理器)的其他资源。 BLOCKED - 线程被阻塞等待一个monitor锁，处于阻塞状态的线程正在等待monitor锁进入 synchronized的代码块或方法，或者在调用Object.wait()方法后重新进入synchronized的代码块 或方法。</li><li><strong>WAITING</strong> - 由于线程调用了 Object.wait(0) ， Thread.join(0) 和 LockSupport.park 其中 的一个方法，线程处于等待状态，其中调用 wait , join 方法时未设置超时时间。还有一种情况， 处于等待状态的线程正在等待另一个线程执行特定的操作，比如：一个线程调用了 Object.wait() 后，等待另一个线程调用 Object.notifyAll() 或 Object.notify() 方法； 或一个线程调用了 Thread.join() 方法，等待自己的线程的结束。</li><li><strong>TIMED_WAITING</strong> - 线程等待一个指定的时间，比如线程调用了 Object.wait(long) , Thread.join(long) , LockSupport.parkNanos , LockSupport.parkUntil 方法之后，线程 的状态就会变成TIMED_WAITING</li><li><strong>TERMINATED</strong> - 终止的线程状态，线程已经完成执行。</li></ul><p><a href="https://imgchr.com/i/r9OMJP" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/09/r9OMJP.png" alt="r9OMJP.png"></a></p><p>Java 线程的生命周期</p><p><a href="https://imgchr.com/i/r9O5QO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/09/r9O5QO.png" alt="r9O5QO.png"></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Java多线程入门&quot;&gt;&lt;a href=&quot;#Java多线程入门&quot; class=&quot;headerlink&quot; title=&quot;Java多线程入门
      
    
    </summary>
    
      <category term="java" scheme="https://lincx_py.gitee.io/categories/java/"/>
    
    
      <category term="并发编程" scheme="https://lincx_py.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>mysql01</title>
    <link href="https://lincx_py.gitee.io/2020/12/06/mysql01/"/>
    <id>https://lincx_py.gitee.io/2020/12/06/mysql01/</id>
    <published>2020-12-06T03:41:09.000Z</published>
    <updated>2020-12-06T03:56:09.725Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="mysql基础知识"><a href="#mysql基础知识" class="headerlink" title="mysql基础知识"></a>mysql基础知识</h1><p>mysql的逻辑架构大概分为三层：</p><p>第一层： 服务层(为客户端服务)<br>为请求做连接处理，授权认证，安全等。</p><p>第二层：核心服务<br>比如查询解析，优化，缓存，内置函数。存储过程，触发器，视图等。对于第二层来说，所以跨存储引擎的功能都在这一层实现。</p><p>第三层：存储引擎<br>负责mysql中数据的存储和提取。服务器通过api与存储引擎通信，这些接口屏蔽了存储引擎之间的差异。也就是说，接口的存在，导致不同存储引擎的差异不会影响到上层查询过程。<br>架构分层之后，可以更好的理解一些问题，比如我们很关心的并发问题：mysql层面的并发控制，实际上是分为两种：</p><ul><li>服务层的并发</li><li>存储引擎层的并发的</li></ul><p><strong>mysql框架</strong></p><p><img src="http://static.notedeep.com/Ft2uVFdLUA_ZvarIxwJOK7pkvpoV" alt=""></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是完全在存储引擎层实现的，所以不同的存储引擎会有不同的锁策略和锁粒度。什么是锁粒度呢？可以简单的理解为，需要锁定的部分的范围。</p><p>常见的锁策略有表锁和行锁。这是按照锁粒度去区分的。<br>显然表锁的粒度更大，并发性能较差，不过CPU的开销小。（上锁也是需要开销的）<br>而行锁的粒度更小，并发性能较好，但是CPU的开销更大。</p><p>假设一种极端的情况，我们需要系统具有最大的并发性。那么，我们在锁策略的选择上就应该选取粒度最小的那种。理想情况就是：<br>尽量只锁定需要修改的那部分数据。<br>锁另一种区分方式是：读锁和写锁。</p><p>读锁又叫共享锁，比如你的网站的多个用户，是可以同时读取同一个资源的。<br>写锁又叫排他锁，写锁的特征就是阻塞。当一个用户在修改某条数据时，其他用户是无法获取到读锁或写锁的。</p><p>当然服务层的某些行为也会给表上锁，比如当执行alter table时，服务器会给该表上表锁。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务即一组原子性的sql查询。</p><p>常规的概念就不说了，这里只提醒三点：</p><ol><li>事务也是在存储引擎层实现的</li><li>事务会带来开销</li><li>一条sql语句也是一个事务</li></ol><h2 id="mysql隔离级别"><a href="#mysql隔离级别" class="headerlink" title="mysql隔离级别"></a>mysql隔离级别</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Read Uncommited（未提交读）</th><th style="text-align:center">Center-alignedRead Commited （提交读）</th><th style="text-align:center">Repeatable Read （可重复读）</th><th style="text-align:center">Serializable （可串行化）</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center">Possible</td><td style="text-align:center">Not Possible</td><td style="text-align:center">Not Possible</td><td style="text-align:center">Not Possible</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center">Possible</td><td style="text-align:center">Possible</td><td style="text-align:center">Not Possible</td><td style="text-align:center">Not Possible</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center">Possible</td><td style="text-align:center">Possible</td><td style="text-align:center">Possible</td><td style="text-align:center">Not Possible</td></tr></tbody></table><p>（从上往下依次增加，较低的隔离级别通常支持较高的并发，系统的开销也更低。因为隔离级别是通过影响锁策略和其他机制去实现效果的，上锁是需要开销的）</p><p>1.Read Uncommited （未提交读）</p><p>事务可以读取未提交的数据，也称脏读。非常可怕，基本不会使用这一级别。</p><p>2.Read Commited （提交读）</p><p>一个事务从开始到提交之前，所做的修改对其他事务是不可见的。但是重复执行同样的查询可能会导致不同的结果。</p><p>3.Repeatable Read （可重复读）</p><p>这是mysql的默认隔离级别，重复执行同样的查询结果相同。</p><p>4.Serializable （可串行化）</p><p>最高的隔离级别，它强制事务串行执行。会导致大量的超时和锁争用问题。虽然数据一致性好，但是并发能力很弱，一般也很少使用。<br>隔离级别先讲到这里，想讲清楚隔离级别是需要先了解lnnodb的。隔离级别的实现，锁机制的实现，以及事务的实现都是依托于一个核心存储引擎。而无数人的经验告诉我们，innodb在绝大多数情况下都会是最佳的选择。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;mysql基础知识&quot;&gt;&lt;a href=&quot;#mysql基础知识&quot; class=&quot;headerlink&quot; title=&quot;mysql基础知识
      
    
    </summary>
    
      <category term="SQL" scheme="https://lincx_py.gitee.io/categories/SQL/"/>
    
    
      <category term="mysql" scheme="https://lincx_py.gitee.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>forum-vue</title>
    <link href="https://lincx_py.gitee.io/2020/09/07/forum-vue/"/>
    <id>https://lincx_py.gitee.io/2020/09/07/forum-vue/</id>
    <published>2020-09-07T12:33:25.000Z</published>
    <updated>2020-09-07T14:12:58.736Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="Vue前端学习心路历程"><a href="#Vue前端学习心路历程" class="headerlink" title="Vue前端学习心路历程"></a>Vue前端学习心路历程</h1><h2 id="一、vue的初体验感受"><a href="#一、vue的初体验感受" class="headerlink" title="一、vue的初体验感受"></a>一、vue的初体验感受</h2><p>学习vue是老师布置的任务里边的一个小任务之一，使用vue.js做一个论坛前台，开始感觉到挺有压力的，因为这是之前没有接触过的框架，而且在学习前还需要学习回顾js的基础，所以刚开始我用了三四天将js的基本内容大概过了一遍，中间直接跳过了jQuery，然后开始在<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js官网</a>直接看文档跟看官网上的一些简短的视频开始了vue.js的学习。可能是因为之前做过微信小程序、springboot web跟gin web的缘故，我感觉vue.js学习起来困难没有开始认为的那么大，一些语法跟前面的几个很相识，特别是微信小程序的模板语法，不同的是vue.js用axios向后端发送请求，这个之前我没有接触过，所以开始的时候会经常犯错，比如post的数据类型content-type默认是”application/json”,但是有时候为了配合后端接收数据，需要改为”application/x-www-form-urlencoded”，还有就是数据放在data里边呢还是放在params，这也是有区别的。在错误处理这一块，我觉得自己还做得不够好，没有做到具体问题反馈具体的错误，大部分都是报“服务端错误”并没有指出具体是什么错误，这样会让用户体验感没有那么好，而且我的错误处理就只是单纯弹出一个警示框，没有跳到指定的页面，不知道这样做好不好。在vue.js学习这一块我只学了一个星期，然后就开始了我的项目。我觉得自己掌握的还不够多，后续还需要继续学习。</p><p>下面是论坛的首页<br><img src="https://s1.ax1x.com/2020/09/07/wK39H0.png" alt="wK39H0.png"></p><h2 id="二、关于vue前后端数据交互"><a href="#二、关于vue前后端数据交互" class="headerlink" title="二、关于vue前后端数据交互"></a>二、关于vue前后端数据交互</h2><ol><li><p>路由映射：在开发阶段，在config-&gt;index.js中的dev可以设置后端请求地址代理，例如下面，当访问http:xxxxx:8080/javaIp/xxxx，这时就会将地址转换为’javaIp’映射的那个ip地址及端口，’/javaIp’，后边的url是不变的<br><img src="https://s1.ax1x.com/2020/09/07/wKZB6K.png" alt=""></p></li><li><p>而在生产环境中，就需要用到nginx进行后端地址代理，在项目过程中，我遇到一个难题，我想使用nginx作为基础镜像，进行部署，开始的时候，我以为在同一个机器上面访问本机端口的话，可以直接写localhost+端口就行，但是我每次build镜像后run都失败，找不到端口，于是我又在网上查了好多钟方法，但是遇到的问题跟我的都不大一样，所以我转向求助前辈跟老师，但是他们说的好像也是跟我遇到的问题不大相同，无奈之下，我在学院的一个交流群里边提了我的困难，还真是有同学碰到过跟我一模一样的问题，他说是nginx里边的localhost跟宿主机器的localhost是不一样的，不能直接通信，然后我再顺着这一个思路在网上找了解决方案，发现都好复杂的样子，最后我就直接将localhost换成了宿主机的ip地址，然后开放相应的端口，这样就解决了。中间还遇到一个小问题，就是下图圈出来的，一定要带上’/‘，不然会访问失败</p></li></ol><p><img src="https://s1.ax1x.com/2020/09/07/wKlHW4.png" alt="wKlHW4.png"></p><h2 id="三、目前还存在的一些小问题"><a href="#三、目前还存在的一些小问题" class="headerlink" title="三、目前还存在的一些小问题"></a>三、目前还存在的一些小问题</h2><ol><li><p>打包完之后的项目，会出现部分样式发生异常变化的现象，最突出的就是一些图标下移的情况，就像下面这样<br><img src="https://s1.ax1x.com/2020/09/07/wK3yvj.png" alt="wK3yvj.png"></p></li><li><p>一些页面下滑页面时顶栏会一闪一闪的，然后消失掉<br><img src="https://s1.ax1x.com/2020/09/07/wKG9YT.png" alt="wKG9YT.png"></p></li><li><p>打开编辑器也会出现像第一种那样的情况，而且本来markdown语法渲染的代码没有颜色的，现在也会出现颜色了，很奇怪，对前端小白来说真的手足无措。之后再看看怎么解决吧，我觉得应该是我引入外部文件出错了</p></li></ol><p>vue的开发经历就先记录这么多吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Vue前端学习心路历程&quot;&gt;&lt;a href=&quot;#Vue前端学习心路历程&quot; class=&quot;headerlink&quot; title=&quot;Vue前端
      
    
    </summary>
    
      <category term="javascript" scheme="https://lincx_py.gitee.io/categories/javascript/"/>
    
    
      <category term="vue.js" scheme="https://lincx_py.gitee.io/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>microproject</title>
    <link href="https://lincx_py.gitee.io/2020/08/07/microproject/"/>
    <id>https://lincx_py.gitee.io/2020/08/07/microproject/</id>
    <published>2020-08-07T07:33:17.000Z</published>
    <updated>2020-08-07T08:45:28.834Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="microproject介绍及部署"><a href="#microproject介绍及部署" class="headerlink" title="microproject介绍及部署"></a>microproject介绍及部署</h1><h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>学习微服务跟k8s花费的时间太长了，大部分时间都是花费在环境的搭建上边的</p><p>这次micro项目做的是一个简单的api跟web请求，下面是项目的目录结构</p><p>微服务使用了go-micro这个框架，详细的项目在这<a href="https://github.com/lincxpy/Goproject/tree/master/microproject" target="_blank" rel="noopener">microproject</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>k8s的环境准备（这个我配的时候搞了好久，要用到vpn，下载的速度还贼慢，又没有找到其他的方法，这里就不讲k8s了，以后再另外写一篇）</p><p>看网上建议，k3s比较轻便，又具备了k8s的绝大部分功能</p><ul><li><strong>完美适配边缘环境</strong> k3s是一个高可用的、经过CNCF认证的Kubernetes发行版，专为无人值守、资源受限、偏远地区或物联网设备内部的生产工作负载而设计</li><li><strong>简单且安全</strong> k3s被打包成单个小于60MB的二进制文件，从而减少了运行安装、运行和自动更新生产Kubernetes集群所需的依赖性和步骤。</li><li><strong>针对ARM进行优化</strong> ARM64和ARMv7都支持二进制文件和多源镜像。k3s在小到树莓派或大到 AWS a1.4xlarge 32GiB服务器的环境中均能出色工作。</li></ul><p><a href="https://www.rancher.cn/k3s/" target="_blank" rel="noopener">了解更多….</a></p><p>k3s安装成功后，开始进行项目镜像打包</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_6eb5588f4ab92ea6f3587147cef5abb8.png" alt=""></p><p>我的思路是将各个服务分开打包，再一一部署</p><p><strong>1、先编写dockerfile，以其中一个为例</strong><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">FROM</span> <span class="attr">centos:latest</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为我们的镜像设置必要的环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">mkdir</span> <span class="string">/app</span></span><br><span class="line"></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/app</span></span><br><span class="line"></span><br><span class="line"><span class="string">COPY</span> <span class="string">web_srv</span> <span class="string">/app</span></span><br><span class="line"></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">8200</span></span><br><span class="line"></span><br><span class="line"><span class="string">CMD</span> <span class="string">[</span> <span class="string">"./web_srv"</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p></p><p>在与dockerfile同意目录下，构建镜像命令<br></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xxxx .</span><br></pre></td></tr></table></figure><p></p><p>注：不知道为什么使用alpine 作为基础镜像，会出现错误，然后网上说是unix的格式错误，不过一般错误是在windows系统编译下才会产生的，但是我是在ubuntu编译的</p><p><strong>2、接下来将镜像上传到阿里云镜像仓库，这里先要注册阿里云账号，再配置阿里云加速器</strong></p><p>命令行登录阿里云账号<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=xxxxx registry.cn-shenzhen.aliyuncs.com</span><br></pre></td></tr></table></figure><p></p><p>为本地镜像添加tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像id registry.cn-shenzhen.aliyuncs.com/xxxx/web_srv:0.1</span><br></pre></td></tr></table></figure><p>push到docker仓库<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-shenzhen.aliyuncs.com/xxxx/web_srv:0.1</span><br></pre></td></tr></table></figure><p></p><p><strong>3、下面就到了部署到k3s了</strong><br>先发布应用，编写deployment.yaml文件<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">web-srv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      project:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">web-srv</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        project:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">web-srv</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      imagePullSecrets:</span> </span><br><span class="line"><span class="attr">      - name:</span> <span class="string">"docker-regsitry-auth"</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/xxxx/web_srv:1.0</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">web-srv</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8200</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">web-srv</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">            port:</span> <span class="number">8200</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">          timeoutSeconds:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">            port:</span> <span class="number">8200</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">          timeoutSeconds:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p></p><p>运行命令<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo k3s kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><p></p><p>然后检查是否发布成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo k3s kubectl get deployment</span><br></pre></td></tr></table></figure><p>想看每个pod的情况运行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo k3s kubectl get pod</span><br></pre></td></tr></table></figure><p></p><p>想看每个pod的日志<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo k3s kubectl logs podname</span><br></pre></td></tr></table></figure><p></p><p><strong>4、创建service暴露服务</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web-srv</span><br><span class="line">  name: web-srv</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8200</span><br><span class="line">    nodePort: 30018</span><br><span class="line">  selector:</span><br><span class="line">    app: web-srv</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure><p></p><p>运行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo k3s kubectl apply -f service.yaml</span><br></pre></td></tr></table></figure><p></p><p>然后我们就可以通过30018这个端口访问服务了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://ip:30018/user/lin&quot;</span><br></pre></td></tr></table></figure><p></p><p><strong>5、使用ingress对外发布服务</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web-srv</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: xxxx.xxxx.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: web-srv</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></figure><p></p><p>运行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo k3s kubectl apply -f ingress.yaml</span><br></pre></td></tr></table></figure><p></p><p><strong>6、更新</strong></p><p>这个更新就很厉害，不是马上杀死服务再建立服务，而是一个缓慢衰亡，中间建立起来新服务</p><p>到此部署完毕</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;microproject介绍及部署&quot;&gt;&lt;a href=&quot;#microproject介绍及部署&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="microservice" scheme="https://lincx_py.gitee.io/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>microservice_3</title>
    <link href="https://lincx_py.gitee.io/2020/07/13/microservice-1/"/>
    <id>https://lincx_py.gitee.io/2020/07/13/microservice-1/</id>
    <published>2020-07-13T02:06:52.000Z</published>
    <updated>2020-07-13T03:16:37.517Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><h1 id="微服务学习篇"><a href="#微服务学习篇" class="headerlink" title="微服务学习篇"></a>微服务学习篇</h1><h2 id="1-数据库的服务化切分"><a href="#1-数据库的服务化切分" class="headerlink" title="1.数据库的服务化切分"></a>1.数据库的服务化切分</h2><h3 id="1-1什么是“分裤分表”"><a href="#1-1什么是“分裤分表”" class="headerlink" title="1.1什么是“分裤分表”"></a>1.1什么是“分裤分表”</h3><p>随着大数据时代的到来，业务系统的数据量日益增大，数据存储能力逐渐成为影响系统性能的瓶颈。目前主流的关系型数据库单表存储上限为1000万条记录，而这一存储能力显然已经无法满足大数据背景下的业务系统存储要求了。随着微服务架构、分布式存储等概念的出现，数据存储问题也渐渐迎来了转机。而数据分片是目前解决海量数据持久化存储与高效查询的一种重要手段。数据分库分表的过程在系统设计阶段完成，要求系统设计人员根据系统预期的业务量，将未来可能出现瓶颈的数据库、数据表按照一定规则拆分成多个库、多张表。这些数据库和数据表需要部署在不同的服务器上，从而将数据读写压力分摊至集群中的各个节点，提升数据库整体处理能力，避免出现读写瓶颈的现象。</p><p>目前数据分片的方式一共有两种：离散分片和连续分片。</p><p>离散分片是按照数据的某一字段哈希取模后进行分片存储。只要哈希算法选择得当，数据就会均匀地分布在不同的分片中，从而将读写压力平均分配给所有分片，整体上提升数据的读写能力。然而，离散存储要求数据之间有较强的独立性，但实际业务系统并非如此，不同分片之间的数据往往存在一定的关联性，因此在某些场景下需要跨分片连接查询。由于目前所有的关系型数据库出于安全性考虑，均不支持跨库连接。因此，跨库操作需要由数据分库分表中间件来完成，这极大影响数据的查询效率。此外，当数据存储能力出现瓶颈需要扩容时，离散分片规则需要将所有数据重新进行哈希取模运算，这无疑成为限制系统可扩展性的一个重要因素。虽然，一致性哈希能在一定程度上减少系统扩容时的数据迁移，但数据迁移问题仍然不可避免。对于一个已经上线运行的系统而言，系统停止对外服务进行数据迁移的代价太大。</p><p>第二种数据分片的方式即为连续分片，它能解决系统扩容时产生的数据迁移问题。这种方式要求数据按照时间或连续自增主键连续存储。从而一段时间内的数据或相邻主键的数据会被存储在同一个分片中。当需要增加分片时，不会影响现有的分片。因此，连续分片能解决扩容所带来的数据迁移问题。但是，数据的存储时间和读写频率往往呈正比，也就是大量的读写往往都集中在最新存储的那一部分数据，这就会导致热点问题，并不能起到分摊读写压力的初衷。</p><h3 id="1-2数据库拓展的几种方式"><a href="#1-2数据库拓展的几种方式" class="headerlink" title="1.2数据库拓展的几种方式"></a>1.2数据库拓展的几种方式</h3><p>数据库拓展一共有四种分配方式，分别是垂直分库、垂直分表、水平分表、水平数据分片。每一个策略都有各自的应用场景。</p><h4 id="1-2-1-垂直分库"><a href="#1-2-1-垂直分库" class="headerlink" title="1.2.1.垂直分库"></a>1.2.1.垂直分库</h4><p>垂直分库即是将一个完整的数据库根据业务功能拆分成多个独立的数据库，这些数据库可以运行在不同的服务器上，从而提升数据库整体的数据读写性能。这种方式在微服务架构中非常常用。微服务架构的核心思想是将一个完整的应用按照业务功能拆分成多个可独立运行的子系统，这些子系统称为“微服务”，各个服务之间通过RPC接口通信，这样的结构使得系统耦合度更低、更易于扩展。垂直分库的理念与微服务的理念不谋而合，可以将原本完整的数据按照微服务拆分系统的方式，拆分成多个独立的数据库，使得每个微服务系统都有各自独立的数据库，从而可以避免单个数据库节点压力过大，影响系统的整体性能，如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/11/162140b0cebe0f17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="1-2-2-垂直分表"><a href="#1-2-2-垂直分表" class="headerlink" title="1.2.2.垂直分表"></a>1.2.2.垂直分表</h4><p>垂直分表如果一张表的字段非常多，那么很有可能会引起数据的跨页存储，这会造成数据库额外的性能开销，而垂直分表可以解决这个问题。垂直分表就是将一张表中不常用的字段拆分到另一张表中，从而保证第一章表中的字段较少，避免出现数据库跨页存储的问题，从而提升查询效率。而另一张表中的数据通过外键与第一张表进行关联，如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/11/162140df47d13a5e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="1-2-3-水平分表"><a href="#1-2-3-水平分表" class="headerlink" title="1.2.3.水平分表"></a>1.2.3.水平分表</h4><p>如果一张表中的记录数过多（超过1000万条记录），那么会对数据库的读写性能产生较大的影响，虽然此时仍然能够正确地读写，但读写的速度已经到了业务无法忍受的地步，此时就需要使用水平分表来解决这个问题。水平分表是将一张含有很多记录数的表水平切分，拆分成几张结构相同的表。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/11/162140e408031cba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="1-2-4-水平分库分表"><a href="#1-2-4-水平分库分表" class="headerlink" title="1.2.4.水平分库分表"></a>1.2.4.水平分库分表</h4><p>水平数据分片与数据分片区别在于：水平数据分片首先将数据表进行水平拆分，然后按照某一分片规则存储在多台数据库服务器上。从而将单库的压力分摊到了多库上，从而避免因为数据库硬件资源有限导致的数据库性能瓶颈，如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/11/162140e71d1d21e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="1-3-分库分表的几个方式"><a href="#1-3-分库分表的几个方式" class="headerlink" title="1.3.分库分表的几个方式"></a>1.3.分库分表的几个方式</h3><h4 id="1-3-1-离散分片"><a href="#1-3-1-离散分片" class="headerlink" title="1.3.1.离散分片"></a>1.3.1.离散分片</h4><p>离散分片是指将数据打散之后均匀地存储在逻辑表的各个分片中，从而使的对同一张逻辑表的数据读取操作均匀地落在不同库的不同表上，从而提高读写速度。离散分片一般以哈希取模的方式实现。比如：一张逻辑表有4个分片，那么在读写数据的时候，中间件首先会取得分片字段的哈希值，然后再模以4，从而计算出该条记录所在的分片。在这种方法中，只要哈希算法选的好，那么数据分片将会比较均匀，从而数据读写就会比较均匀地落在各个分片上，从而就有较高的读写效率。但是，这种方式也存在一个最大的缺陷——数据库扩容成本较高。采用这种方式，如果需要再增加分片，原先的分片算法将失效，并且所有记录都需要重新计算所在分片的位置。对于一个已经上线的系统来说，行级别的数据迁移成本相当高，而且由于数据迁移期间系统仍在运行，仍有新数据产生，从而无法保证迁移过程数据的一致性。如果为了避免这个问题而停机迁移，那必然会对业务造成巨大影响。当然，如果为了避免数据迁移，在一开始的时候就分片较多的分片，那需要承担较高的费用，这对于中小公司来说是无法承受的。</p><h4 id="1-3-2-连续分片"><a href="#1-3-2-连续分片" class="headerlink" title="1.3.2.连续分片"></a>1.3.2.连续分片</h4><p>连续分片指的是按照某一种分片规则，将某一个区间内的数据存储在同一个分片上。比如按照时间分片，每个月生成一张物理表。那么在读写数据时，直接根据当前时间就可以找到数据所在的分片。再比如可以按照记录ID分片，这种分片方式要求ID需要连续递增。由于Mysql数据库单表支持最大的记录数约为1000万，因此我们可以根据记录的ID，使得每个分片存储1000万条记录，当目前的记录数即将到达存储上限时，我们只需增加分片即可，原有的数据无需迁移。连续分片的一个最大好处就是方便扩容，因为它不需要任何的数据迁移。但是，连续分片有个最大的缺点就是热点问题。连续分片使得新插入的数据集中在同一个分片上，而往往新插入的数据读写频率较高，因此，读写操作都会集中在最新的分片上，从而无法体现数据分片的优势</p><h3 id="1-4-引入分库分表中间件后面临的问题"><a href="#1-4-引入分库分表中间件后面临的问题" class="headerlink" title="1.4.引入分库分表中间件后面临的问题"></a>1.4.引入分库分表中间件后面临的问题</h3><h4 id="1-4-1-跨库操作"><a href="#1-4-1-跨库操作" class="headerlink" title="1.4.1.跨库操作"></a>1.4.1.跨库操作</h4><p>在关系型数据库中，多张表之间往往存在关联，我们在开发过程中需要使用JOIN操作进行多表连接。但是当我们使用了分库分表模式后，由于数据库厂商处于安全考虑，不允许跨库JOIN操作，从而如果需要连接的两张表被分到不同的库中后，就无法使用SQL提供的JOIN关键字来实现表连接，我们可能需要在业务系统层面，通过多次SQL查询，完成数据的组装和拼接。这一方面会增加业务系统的复杂度，另一方面会增加业务系统的负载。<br>因此，当我们使用分库分表模式时，需要根据具体的业务场景，合理地设置分片策略、设置分片字段</p><h4 id="1-4-2-分布式事务"><a href="#1-4-2-分布式事务" class="headerlink" title="1.4.2.分布式事务"></a>1.4.2.分布式事务</h4><p>我们知道，数据库提供了事务的功能，以保证数据一致性。然而，这种事务只是针对单数据库而言的，数据库厂商并未提供跨库事务。因此，当我们使用了分库分表之后，就需要我们在业务系统层面实现分布式事务</p><h2 id="2-微服务架构中的分布式事务"><a href="#2-微服务架构中的分布式事务" class="headerlink" title="2.微服务架构中的分布式事务"></a>2.微服务架构中的分布式事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库能实现本地事务，也就是在同一个数据库中，你可以允许一组操作要么全都正确执行，要么全都不执行。这里特别强调了本地事务，也就是目前的数据库只能支持同一个数据库中的事务。但现在的系统往往采用微服务架构，业务系统拥有独立的数据库，因此就出现了跨多个数据库的事务需求，这种事务即为“分布式事务”。</span><br></pre></td></tr></table></figure><h3 id="2-1-分布式事务是什么"><a href="#2-1-分布式事务是什么" class="headerlink" title="2.1.分布式事务是什么"></a>2.1.分布式事务是什么</h3><p>事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。</p><h3 id="2-2-事务的四大特性"><a href="#2-2-事务的四大特性" class="headerlink" title="2.2.事务的四大特性"></a>2.2.事务的四大特性</h3><p>这里举一个分布式事务的典型例子——用户下单过程。<br>当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：</p><ol><li>用户通过商品系统浏览商品，他看中了某一项商品，便点击下单</li><li>此时订单系统会生成一条订单</li><li><p>订单创建成功后，支付系统提供支付功能</p></li><li><p>当支付完成后，由积分系统为该用户增加积分</p></li></ol><p>上述步骤2、3、4需要在一个事务中完成。对于传统单体应用而言，实现事务非常简单，只需将这三个步骤放在一个方法A中，再用Spring的@Transactional注解标识该方法即可。Spring通过数据库的事务支持，保证这些步骤要么全都执行完成，要么全都不执行。但在这个微服务架构中，这三个步骤涉及三个系统，涉及三个数据库，此时我们必须在数据库和应用系统之间，通过某项黑科技，实现分布式事务的支持。</p><h3 id="2-3-分布式事务协议"><a href="#2-3-分布式事务协议" class="headerlink" title="2.3.分布式事务协议"></a>2.3.分布式事务协议</h3><h4 id="2-3-1-两阶段提交协议-2PC"><a href="#2-3-1-两阶段提交协议-2PC" class="headerlink" title="2.3.1.两阶段提交协议 2PC"></a>2.3.1.两阶段提交协议 2PC</h4><p>分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。为实现这个目的，二阶段提交算法的成立基于以下假设：</p><ul><li>该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li></ul><ol><li><p>第一阶段（投票阶段）：</p><ol><li>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</li><li>参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</li><li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li></ol></li><li><p>第二阶段（提交执行阶段）：<br>当协调者节点从所有参与者节点获得的相应消息都为”同意”时：</p><ol><li>协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”完成”消息。</li><li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol></li></ol><p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p><ol><li>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”回滚完成”消息。<br>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li></ol><p>不管最后结果如何，第二阶段都会结束当前事务。<br>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：</p><ol><li>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li><li>参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）</li><li>协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。（这个可以依赖后面要讲的Paxos协议实现HA）</li><li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ol><p>为此，Dale Skeen和Michael Stonebraker在“A Formal Model of Crash Recovery in a Distributed System”中提出了三阶段提交协议（3PC）。</p><h4 id="3-8-2-三阶段提交协议-3PC"><a href="#3-8-2-三阶段提交协议-3PC" class="headerlink" title="3.8.2 三阶段提交协议 3PC"></a>3.8.2 三阶段提交协议 3PC</h4><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><p>引入超时机制。同时在协调者和参与者中都引入超时机制。<br>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p><p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</p><ol><li>CanCommit阶段<br>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</li></ol><pre><code>1. 事务询问</code></pre><p>协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p><pre><code>2. 响应反馈</code></pre><p>参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p><ol start="2"><li>PreCommit阶段<br>协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。<br>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</li></ol><pre><code>1. 发送预提交请求</code></pre><p>协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p><pre><code>2. 事务预提交</code></pre><p>参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p><pre><code>3. 响应反馈</code></pre><p>如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><pre><code>1. 发送中断请求协调者向所有参与者发送abort请求。2. 中断事务参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</code></pre><ol start="3"><li>doCommit阶段<br>该阶段进行真正的事务提交，也可以分为以下两种情况。<br>该阶段进行真正的事务提交，也可以分为以下两种情况。<br>3.1 执行提交</li></ol><pre><code>1. 发送提交请求</code></pre><p>协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p><pre><code>2. 事务提交</code></pre><p>参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p><pre><code>3. 响应反馈</code></pre><p>事务提交完之后，向协调者发送Ack响应。</p><pre><code>4. 完成事务</code></pre><p>协调者接收到所有参与者的ack响应之后，完成事务。</p><p>3.2 中断事务<br>协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><pre><code>1. 发送中断请求协调者向所有参与者发送abort请求2. 事务回滚参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。3. 反馈结果参与者完成事务回滚之后，向协调者发送ACK消息4. 中断事务协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;微服务学习篇&quot;&gt;&lt;a href=&quot;#微服务学习篇&quot; class=&quot;headerlink&quot; title=&quot;微服务学习篇&quot;&gt;&lt;/a&gt;微服务
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="microservice" scheme="https://lincx_py.gitee.io/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>microservice_2</title>
    <link href="https://lincx_py.gitee.io/2020/06/10/microservice-2/"/>
    <id>https://lincx_py.gitee.io/2020/06/10/microservice-2/</id>
    <published>2020-06-10T01:16:06.000Z</published>
    <updated>2020-06-09T13:35:38.617Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>占据着云计算的优势，微服务架构越来越流行，同时它的云端分布式的运行环境也对我们的开发、测试和部署提出了很高的要求，容器（container）便是一项解决方案。</p><p>在传统软件开发中，应用直接部署在环境和依赖都准备好的系统上，或在一台物理服务器上部署在由 Chef 或 Puppet 管理的虚拟集群里。这种部署方案不利于横向扩展，比如要部署多台物理服务器，需要都安装相同的依赖，再部署，很是麻烦。</p><p>vagrant 这类管理多个虚拟机的工具，虽然使项目的部署更为遍历，但每个虚拟机都运行有一个完整的操作系统，十分耗费宿主主机的资源，并不适合微服务的开发和部署。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>容器 是精简版的操作系统，但并不运行一个 kernel 或系统底层相关的驱动，它只包含一些 run-time 必需的库，多个容器共享宿主主机的 kernel，多个容器之间相互隔离，互补影响。可参考：Redhat topic</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>容器的运行环境只包含代码所需要的依赖，而不是使用完整的操作系统包含一大堆不需要的组件。此外，容器本身的体积相比虚拟机是比较小的，比如对比 ubuntu 16.04 优势不言而喻,普通镜像1.4G，docker 112M</p><h3 id="Docker与容器"><a href="#Docker与容器" class="headerlink" title="Docker与容器"></a>Docker与容器</h3><p>一般人会认为容器技术就是 Docker，实则不然，Docker 只是容器技术的一种实现，因为其操作简便且学习门槛低，所以如此流行。</p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>创建微服务部署的 <code>Dockerfile</code><br></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若运行环境是 Linux 则需把 alpine 换成 debian</span></span><br><span class="line"><span class="comment"># 使用最新版 alpine 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器的根目录下创建 app 目录</span></span><br><span class="line"><span class="keyword">RUN</span> mkdir /app</span><br><span class="line"></span><br><span class="line"># 将工作目录切换到 /app 下</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将微服务的服务端运行文件拷贝到 /app 下</span><br><span class="line">ADD consignment-service /app/consignment-service</span><br><span class="line"></span><br><span class="line"># 运行服务端</span><br><span class="line">CMD ["./consignment-service"]</span><br></pre></td></tr></table></figure><p></p><p>alpine 是一个超轻量级 Linux 发行版本，专为 Docker 中 Web 应用而生。它能保证绝大多数 web 应用可以正常运行，即使它只包含必要的 run-time 文件和依赖，镜像大小只有 4 MB，相比上边 Ubuntu16.4 节约了 99.7% 的空间：</p><h2 id="Go-micro"><a href="#Go-micro" class="headerlink" title="Go-micro"></a>Go-micro</h2><h3 id="为什么不继续使用-gRPC"><a href="#为什么不继续使用-gRPC" class="headerlink" title="为什么不继续使用 gRPC ?"></a>为什么不继续使用 gRPC ?</h3><p><strong>管理麻烦</strong></p><p>在客户端代码（consignment-cli/cli.go）中，我们手动指定了服务端的地址和端口，在本地修改不是很麻烦。但在生产环境中，各服务可能不在同一台主机上（分布式独立运行），其中任一服务重新部署后 IP 或运行的端口发生变化，其他服务将无法再调用它。如果你有很多个服务，彼此指定 IP 和端口来相互调用，那管理起来很麻烦</p><p><strong>服务发现</strong></p><p>为解决服务间的调用问题，服务发现（service discovery）出现了，它作为一个注册中心会记录每个微服务的 IP 和端口，各微服务上线时会在它那注册，下线时会注销，其他服务可通过名字或 ID 找到该服务类比门面模式。</p><p>综上，选用go-micro既可达到我们的目的也能避免重复造轮子</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/micro/protobuf/proto</span><br><span class="line"><span class="keyword">go</span> get -u github.com/micro/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure><h3 id="go-micro简介"><a href="#go-micro简介" class="headerlink" title="go-micro简介"></a>go-micro简介</h3><ul><li>Go Micro是一个插件化的基础框架，基于此可以构建微服务，Micro的设计哲学是可插拔的插件化架构</li><li>在架构之外，它默认实现了consul作为服务发现（2019年源码修改了默认使用mdns），通过http进行通信，通过protobuf和json进行编解码</li></ul><h3 id="go-micro主要功能"><a href="#go-micro主要功能" class="headerlink" title="go-micro主要功能"></a>go-micro主要功能</h3><ul><li><strong>服务发现</strong>：自动服务注册和名称解析。服务发现是微服务开发的核心。当服务A需要与服务B通话时，它需要该服务的位置。默认发现机制是多播DNS（mdns），一种零配置系统。您可以选择使用SWIM协议为p2p网络设置八卦，或者为弹性云原生设置设置consul</li><li><strong>负载均衡</strong>：基于服务发现构建的客户端负载均衡。一旦我们获得了服务的任意数量实例的地址，我们现在需要一种方法来决定要路由到哪个节点。我们使用随机散列负载均衡来提供跨服务的均匀分布，并在出现问题时重试不同的节点</li><li><strong>消息编码</strong>：基于内容类型的动态消息编码。客户端和服务器将使用编解码器和内容类型为您无缝编码和解码Go类型。可以编码任何种类的消息并从不同的客户端发送。客户端和服务器默认处理此问题。这包括默认的protobuf和json</li><li><strong>请求/响应</strong>：基于RPC的请求/响应，支持双向流。我们提供了同步通信的抽象。对服务的请求将自动解决，负载平衡，拨号和流式传输。启用tls时，默认传输为http / 1.1或http2</li><li><strong>Async Messaging</strong>：PubSub是异步通信和事件驱动架构的一流公民。事件通知是微服务开发的核心模式。启用tls时，默认消息传递是点对点http / 1.1或http2</li><li><strong>可插拔接口</strong>：Go Micro为每个分布式系统抽象使用Go接口，因此，这些接口是可插拔的，并允许Go Micro与运行时无关，可以插入任何基础技术</li></ul><h3 id="go-micro通信流程"><a href="#go-micro通信流程" class="headerlink" title="go-micro通信流程"></a>go-micro通信流程</h3><ul><li>Server监听客户端的调用，和Brocker推送过来的信息进行处理。并且Server端需要向Register注册自己的存在或消亡，这样Client才能知道自己的状态</li><li>Register服务的注册的发现，Client端从Register中得到Server的信息，然后每次调用都根据算法选择一个的Server进行通信，当然通信是要经过编码/解码，选择传输协议等一系列过程的</li><li>如果有需要通知所有的Server端可以使用Brocker进行信息的推送，Brocker 信息队列进行信息的接收和发布</li></ul><h3 id="go-micro核心接口"><a href="#go-micro核心接口" class="headerlink" title="go-micro核心接口"></a>go-micro核心接口</h3><p>go-micro之所以可以高度订制和他的框架结构是分不开的，go-micro由8个关键的interface组成，每一个interface都可以根据自己的需求重新实现，这8个主要的inteface也构成了go-micro的框架结构<br><img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></p><h3 id="第一个go-micro服务实例"><a href="#第一个go-micro服务实例" class="headerlink" title="第一个go-micro服务实例"></a>第一个go-micro服务实例</h3><p>简单的做个web实例<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/micro/go-micro/v2/web"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">server:=web.NewService(web.Address(<span class="string">":8080"</span>))</span><br><span class="line">server.HandleFunc(<span class="string">"/"</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>配合gin框架<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"github.com/micro/go-micro/v2/web"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">router:= gin.Default()</span><br><span class="line">router.Handle(<span class="string">"GET"</span>,<span class="string">"/my"</span>,<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">c.String(http.StatusOK,<span class="string">"my api"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server:=web.NewService(web.Address(<span class="string">":8080"</span>),web.Handler(router))</span><br><span class="line">server.Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;go-micro&quot;&gt;&lt;a href=&quot;#go-micro&quot; class=&quot;headerlink&quot; title=&quot;go-micro&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="microservice" scheme="https://lincx_py.gitee.io/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>microservice_1</title>
    <link href="https://lincx_py.gitee.io/2020/06/09/micro-server-1/"/>
    <id>https://lincx_py.gitee.io/2020/06/09/micro-server-1/</id>
    <published>2020-06-09T07:35:36.000Z</published>
    <updated>2020-06-09T11:05:00.286Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><h1 id="Golang-and-Micro-service"><a href="#Golang-and-Micro-service" class="headerlink" title="Golang and Micro service"></a>Golang and Micro service</h1><h2 id="一、微服务"><a href="#一、微服务" class="headerlink" title="一、微服务"></a>一、微服务</h2><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Golang, gRPC, <span class="keyword">go</span>-micro<span class="comment">// 开发语言及其 RPC 框架</span></span><br><span class="line">Google Cloud, MongoDB<span class="comment">// 云平台与数据存储</span></span><br><span class="line">Docker, Kubernetes, Terrafrom  <span class="comment">// 容器化与集群架构</span></span><br><span class="line">NATS, CircleCI<span class="comment">// 消息系统与持续集成</span></span><br></pre></td></tr></table></figure><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u google.golang.org/grpc# 安装 gRPC 框架</span><br><span class="line"><span class="keyword">go</span> get -u github.com/golang/protobuf/protoc-gen-<span class="keyword">go</span># 安装 Go 版本的 protobuf 编译器</span><br></pre></td></tr></table></figure><h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h3><p>在传统的软件开发中，整个应用的代码都组织在一个单一的代码库，一般会有以下拆分代码的形式：</p><ul><li>按照特征做拆分：如 MVC 模式<br>按照功能做拆分：在更大的项目中可能会将代码封装在处理不同业务的包中，包内部可能会再做拆分</li><li>不管怎么拆分，最终二者的代码都会集中在一个库中进行开发和管理，可参考：<a href="http://www.ruanyifeng.com/blog/2016/07/google-monolithic-source-repository.html" target="_blank" rel="noopener">谷歌的单一代码库管理</a></li></ul><p>微服务是上述第二种拆分方式的拓展，按功能将代码拆分成几个包，都是可独立运行的单一代码库。区别如下：<br><img src="https://user-gold-cdn.xitu.io/2018/5/30/163afb1eecd1bc80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="微服务优势有哪些？"><a href="#微服务优势有哪些？" class="headerlink" title="微服务优势有哪些？"></a>微服务优势有哪些？</h3><ul><li><p><strong>降低复杂性</strong><br>将整个应用的代码按功能对应拆分为小且独立的微服务代码库，这不禁让人联想到 Unix 哲学：Do One Thing and Do It Well，在传统单一代码库的应用中，模块之间是紧耦合且边界模糊的，随着产品不断迭代，代码的开发和维护将变得更为复杂，潜在的 bug 和漏洞也会越来越多。</p></li><li><p><strong>提高扩展性</strong><br>在项目开发中，可能有一部分代码会在多个模块中频繁的被用到，这种复用性很高的模块常常会抽离出来作为公共代码库使用，比如验证模块，当它要扩展功能（添加短信验证码登录等）时，单一代码库的规模只增不减， 整个应用还需重新部署。在微服务架构中，验证模块可作为单个服务独立出来，能独立运行、测试和部署。</p></li><li>遵循微服务拆分代码的理念，能大大降低模块间的耦合性，横向扩展也会容易许多，正适合当下云计算的高性能、高可用和分布式的开发环境。</li></ul><h3 id="使用-Golang-的好处？"><a href="#使用-Golang-的好处？" class="headerlink" title="使用 Golang 的好处？"></a>使用 Golang 的好处？</h3><p>微服务是一种架构理念而不是具体的框架项目，许多编程语言都可以实现，但有的语言对微服务开发具备天生的优势，Golang 便是其中之一</p><p>Golang 本身十分轻量级，运行效率极高，同时对并发编程有着原生的支持，从而能更好的利用多核处理器。内置 net 标准库对网络开发的支持也十分完善。</p><h2 id="Protobuf-与-gRPC"><a href="#Protobuf-与-gRPC" class="headerlink" title="Protobuf 与 gRPC"></a>Protobuf 与 gRPC</h2><p>在传统应用的单一代码库中，各模块间可直接相互调用函数。但在微服务架构中，由于每个服务对应的代码库是独立运行的，无法直接调用，彼此间的通信就是个大问题，解决方案有 2 个:</p><p><strong>JSON 或 XML 协议的 API</strong></p><p>微服务之间可使用基于 HTTP 的 JSON 或 XML 协议进行通信：服务 A 与服务 B 进行通信前，A 必须把要传递的数据 encode 成 JSON / XML 格式，再以字符串的形式传递给 B，B 接收到数据需要 decode 后才能在代码中使用：</p><ul><li>优点：数据易读，使用便捷，是与浏览器交互必选的协议</li><li>缺点：在数据量大的情况下 encode、decode 的开销随之变大，多余的字段信息导致传输成本更高</li></ul><p><strong>RPC 协议的 API</strong></p><p>下边的 JSON 数据就使用 description、weight 等元数据来描述数据本身的意义，在 Browser / Server 架构中用得很多，以方便浏览器解析：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"This is a test consignment"</span>,</span><br><span class="line">  <span class="string">"weight"</span>: <span class="number">550</span>,</span><br><span class="line">  <span class="string">"containers"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"customer_id"</span>: <span class="string">"cust001"</span>,</span><br><span class="line">      <span class="string">"user_id"</span>: <span class="string">"user001"</span>,</span><br><span class="line">      <span class="string">"origin"</span>: <span class="string">"Manchester, United Kingdom"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"vessel_id"</span>: <span class="string">"vessel001"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但在两个微服务之间通信时，若彼此约定好传输数据的格式，可直接使用二进制数据流进行通信，不再需要笨重冗余的元数据。</p><h3 id="gRPC-简介"><a href="#gRPC-简介" class="headerlink" title="gRPC 简介"></a>gRPC 简介</h3><p>gRPC 是谷歌开源的轻量级 RPC 通信框架，其中的通信协议基于二进制数据流，使得 gRPC 具有优异的性能。</p><p>gRPC 支持 HTTP 2.0 协议，使用二进制帧进行数据传输，还可以为通信双方建立持续的双向数据流。</p><h3 id="protobuf-作为通信协议"><a href="#protobuf-作为通信协议" class="headerlink" title="protobuf 作为通信协议"></a>protobuf 作为通信协议</h3><p>两个微服务之间通过基于 HTTP 2.0 二进制数据帧通信，那么如何约定二进制数据的格式呢？答案是使用 gRPC 内置的 protobuf 协议，其 DSL 语法 可清晰定义服务间通信的数据结构。</p><h2 id="简单的微服务开发"><a href="#简单的微服务开发" class="headerlink" title="简单的微服务开发"></a>简单的微服务开发</h2><p>实践第一个微服务：<strong>consignment-service</strong></p><h3 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH/src</span><br><span class="line">    └── shippy</span><br><span class="line">        └── consignment-service</span><br><span class="line">            └── proto</span><br><span class="line">                └── consignment</span><br><span class="line">                    └── consignment.proto</span><br></pre></td></tr></table></figure><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/30/163afb1eecede9c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="定义protobuf-通信协议文件"><a href="#定义protobuf-通信协议文件" class="headerlink" title="定义protobuf 通信协议文件"></a>定义protobuf 通信协议文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shipper/consignment-service/proto/consignment/consignment.proto</span></span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> <span class="keyword">go</span>.micro.srv.consignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 货轮微服务</span></span><br><span class="line">service ShippingService &#123;</span><br><span class="line">    <span class="comment">// 托运一批货物</span></span><br><span class="line">    rpc CreateConsignment (Consignment) returns (Response) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 货轮承运的一批货物</span></span><br><span class="line">message Consignment &#123;</span><br><span class="line">    <span class="keyword">string</span> id = <span class="number">1</span>;                      <span class="comment">// 货物编号</span></span><br><span class="line">    <span class="keyword">string</span> description = <span class="number">2</span>;             <span class="comment">// 货物描述</span></span><br><span class="line">    <span class="keyword">int32</span> weight = <span class="number">3</span>;                   <span class="comment">// 货物重量</span></span><br><span class="line">    repeated Container containers = <span class="number">4</span>;  <span class="comment">// 这批货有哪些集装箱</span></span><br><span class="line">    <span class="keyword">string</span> vessel_id = <span class="number">5</span>;               <span class="comment">// 承运的货轮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个集装箱</span></span><br><span class="line">message Container &#123;</span><br><span class="line">    <span class="keyword">string</span> id = <span class="number">1</span>;          <span class="comment">// 集装箱编号</span></span><br><span class="line">    <span class="keyword">string</span> customer_id = <span class="number">2</span>; <span class="comment">// 集装箱所属客户的编号</span></span><br><span class="line">    <span class="keyword">string</span> origin = <span class="number">3</span>;      <span class="comment">// 出发地</span></span><br><span class="line">    <span class="keyword">string</span> user_id = <span class="number">4</span>;     <span class="comment">// 集装箱所属用户的编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 托运结果</span></span><br><span class="line">message Response &#123;</span><br><span class="line">    <span class="keyword">bool</span> created = <span class="number">1</span>;<span class="comment">// 托运成功</span></span><br><span class="line">    Consignment consignment = <span class="number">2</span>;<span class="comment">// 新托运的货物</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/5/30/163afb1eece3443b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="生成协议代码"><a href="#生成协议代码" class="headerlink" title="生成协议代码"></a>生成协议代码</h3><p>（Mac或者Linux可看，windows跳过make file）<br>protoc 编译器使用 grpc 插件编译 .proto 文件<br>为避免重复的在终端执行编译、运行命令，本项目使用 make 工具，新建 consignment-service/Makefile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line"># 一定要注意 Makefile 中的缩进，否则 make build 可能报错 Nothing to be done for build</span><br><span class="line"># protoc 命令前边是一个 Tab，不是四个或八个空格</span><br><span class="line">protoc -I. --go_out=plugins=grpc:$(GOPATH)/src/shippy/consignment-service proto/consignment/consignment.proto</span><br></pre></td></tr></table></figure><p>执行 make build，会在 proto/consignment 目录下生成 consignment.pb.go</p><h3 id="实现服务端"><a href="#实现服务端" class="headerlink" title="实现服务端"></a>实现服务端</h3><p>服务端需实现 ShippingServiceClient 接口，创建consignment-service/main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">// 导如 protoc 自动生成的包</span></span><br><span class="line">pb <span class="string">"shippy/consignment-service/proto/consignment"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">PORT = <span class="string">":50051"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 仓库接口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> IRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">Create(consignment *pb.Consignment) (*pb.Consignment, error) <span class="comment">// 存放新货物</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 我们存放多批货物的仓库，实现了 IRepository 接口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> Repository <span class="keyword">struct</span> &#123;</span><br><span class="line">consignments []*pb.Consignment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *Repository)</span> <span class="title">Create</span><span class="params">(consignment *pb.Consignment)</span> <span class="params">(*pb.Consignment, error)</span></span> &#123;</span><br><span class="line">repo.consignments = <span class="built_in">append</span>(repo.consignments, consignment)</span><br><span class="line"><span class="keyword">return</span> consignment, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *Repository)</span> <span class="title">GetAll</span><span class="params">()</span> []*<span class="title">pb</span>.<span class="title">Consignment</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> repo.consignments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 定义微服务</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">repo Repository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// service 实现 consignment.pb.go 中的 ShippingServiceServer 接口</span></span><br><span class="line"><span class="comment">// 使 service 作为 gRPC 的服务端</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 托运新的货物</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">CreateConsignment</span><span class="params">(ctx context.Context, req *pb.Consignment)</span> <span class="params">(*pb.Response, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 接收承运的货物</span></span><br><span class="line">consignment, err := s.repo.Create(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">resp := &amp;pb.Response&#123;Created: <span class="literal">true</span>, Consignment: consignment&#125;</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">"tcp"</span>, PORT)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"listen on: %s\n"</span>, PORT)</span><br><span class="line"></span><br><span class="line">server := grpc.NewServer()</span><br><span class="line">repo := Repository&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 rRPC 服务器注册微服务</span></span><br><span class="line">    <span class="comment">// 此时会把我们自己实现的微服务 service 与协议中的 ShippingServiceServer 绑定</span></span><br><span class="line">pb.RegisterShippingServiceServer(server, &amp;service&#123;repo&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := server.Serve(listener); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的代码实现了 consignment-service 微服务所需要的方法，并建立了一个 gRPC 服务器监听 50051 端口。</p><h3 id="实现客户端"><a href="#实现客户端" class="headerlink" title="实现客户端"></a>实现客户端</h3><p>我们将要托运的货物信息放到 consignment-cli/consignment.json：<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"This is a test consignment"</span>,</span><br><span class="line">  <span class="attr">"weight"</span>: <span class="number">550</span>,</span><br><span class="line">  <span class="attr">"containers"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"customer_id"</span>: <span class="string">"cust001"</span>,</span><br><span class="line">      <span class="attr">"user_id"</span>: <span class="string">"user001"</span>,</span><br><span class="line">      <span class="attr">"origin"</span>: <span class="string">"Manchester, United Kingdom"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"vessel_id"</span>: <span class="string">"vessel001"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">pb <span class="string">"shippy/consignment-service/proto/consignment"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ADDRESS           = <span class="string">"localhost:50051"</span></span><br><span class="line">DEFAULT_INFO_FILE = <span class="string">"consignment.json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 consignment.json 中记录的货物信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(*pb.Consignment, error)</span></span> &#123;</span><br><span class="line">data, err := ioutil.ReadFile(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> consignment *pb.Consignment</span><br><span class="line">err = json.Unmarshal(data, &amp;consignment)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"consignment.json file content error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consignment, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到 gRPC 服务器</span></span><br><span class="line">conn, err := grpc.Dial(ADDRESS, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"connect error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 gRPC 客户端</span></span><br><span class="line">client := pb.NewShippingServiceClient(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在命令行中指定新的货物信息 json 文件</span></span><br><span class="line">infoFile := DEFAULT_INFO_FILE</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">infoFile = os.Args[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析货物信息</span></span><br><span class="line">consignment, err := parseFile(infoFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"parse info file error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC</span></span><br><span class="line"><span class="comment">// 将货物存储到我们自己的仓库里</span></span><br><span class="line">resp, err := client.CreateConsignment(context.Background(), consignment)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"create consignment error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新货物是否托运成功</span></span><br><span class="line">log.Printf(<span class="string">"created: %t"</span>, resp.Created)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Golang-and-Micro-service&quot;&gt;&lt;a href=&quot;#Golang-and-Micro-service&quot; class
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="microservice" scheme="https://lincx_py.gitee.io/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>k8s_1</title>
    <link href="https://lincx_py.gitee.io/2020/05/22/k8s-1/"/>
    <id>https://lincx_py.gitee.io/2020/05/22/k8s-1/</id>
    <published>2020-05-22T14:03:28.000Z</published>
    <updated>2020-05-22T15:23:17.845Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><h1 id="一、Kubernetes入门"><a href="#一、Kubernetes入门" class="headerlink" title="一、Kubernetes入门"></a>一、Kubernetes入门</h1><h2 id="Kubernetes简介"><a href="#Kubernetes简介" class="headerlink" title="Kubernetes简介"></a>Kubernetes简介</h2><p>Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着（比如用户想让apache一直运行，用户不需要关心怎么去做，Kubernetes会自动去监控，然后去重启，新建，总之，让apache一直提供服务），管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用（就像canary deployments）。</p><p>现在Kubernetes着重于不间断的服务状态（比如web服务器或者缓存服务器）和原生云平台应用（Nosql）,在不久的将来会支持各种生产云平台中的各种服务，例如，分批，工作流，以及传统数据库。<br><img src="https://ae01.alicdn.com/kf/H03f70693750746009d872e5e64072566j.jpg" alt="k8s架构图"></p><h2 id="Kubernetes设计架构"><a href="#Kubernetes设计架构" class="headerlink" title="Kubernetes设计架构"></a>Kubernetes设计架构</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>在这张系统架构图中，我们把服务分为运行在工作节点上的服务和组成集群级别控制板的服务。</p><p>Kubernetes节点有运行应用容器必备的服务，而这些都是受Master的控制。</p><p>每次个节点上当然都要运行Docker。Docker来负责所有具体的映像下载和容器运行。</p><p>Kubernetes主要由以下几个核心组件组成：</p><ul><li>etcd保存了整个集群的状态；</li><li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li><li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li><li>kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</li><li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li><li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li></ul><p>除了核心组件，还有一些推荐的Add-ons：</p><ul><li>kube-dns负责为整个集群提供DNS服务</li><li>Ingress Controller为服务提供外网入口</li><li>Heapster提供资源监控</li><li>Dashboard提供GUI</li><li>Federation提供跨可用区的集群</li><li>Fluentd-elasticsearch提供集群日志采集、存储与查询</li></ul><p>下面是它们之间的关系：</p><p><img src="https://ae01.alicdn.com/kf/H164839b800ce477da5d54e98ab44b382M.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H3371d1a28670452683e94450509d0c52W.jpg" alt=""></p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示</p><p><img src="https://ae01.alicdn.com/kf/H26a8edcf7abc4c94b34ea7ffe4960071o.jpg" alt=""></p><ul><li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）</li><li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴<br>Kubernetes外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS应用、ChatOps等<br>Kubernetes内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等</li></ul><h2 id="Kubernetes设计理念"><a href="#Kubernetes设计理念" class="headerlink" title="Kubernetes设计理念"></a>Kubernetes设计理念</h2><p><strong>Pod</strong></p><p>K8s有很多技术概念，同时对应很多API对象，最重要的也是最基础的是微服务Pod。Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是K8s最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</p><p>Pod是K8s集群中所有业务类型的基础，可以看作运行在K8s集群中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前K8s中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的小机器人控制器为Deployment、Job、DaemonSet和PetSet，本文后面会一一介绍。</p><p><strong>复制控制器（Replication Controller，RC）</strong></p><p>RC是K8s集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是K8s较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的Web服务。</p><p><strong>副本集（Replica Set，RS）</strong></p><p>RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。</p><p><strong>部署(Deployment)</strong></p><p>部署表示用户对K8s集群的一次更新操作。部署是一个比RS应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更通用的Deployment来描述。以K8s的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p><p><strong>服务（Service）</strong></p><p>RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在K8s集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。在K8s集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是K8s集群内部的负载均衡器。它是一个分布式代理服务器，在K8s的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。与之相比，我们平时在服务器端做个反向代理做负载均衡，还要进一步解决反向代理的负载均衡和高可用问题。</p><p><strong>任务（Job）</strong></p><p>Job是K8s用来控制批处理型任务的API对象。批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod根据用户的设置把任务成功完成就自动退出了。成功完成的标志根据不同的spec.completions策略而不同：单Pod型任务有一个Pod成功就标志完成；定数成功型任务保证有N个任务全部成功；工作队列型任务根据应用确认的全局成功而标志成功。</p><p><strong>后台支撑服务集（DaemonSet）</strong></p><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在K8s集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持K8s集群运行的服务。</p><p><strong>有状态服务集（PetSet）</strong></p><p>K8s在1.3版本里发布了Alpha版的PetSet功能。在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）。RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了、名字和启动在哪儿都不重要，重要的只是Pod总数；而PetSet是用来控制有状态服务，PetSet中的每个Pod的名字都是事先确定的，不能更改。PetSet中Pod的名字的作用，并不是《千与千寻》的人性原因，而是关联与该Pod对应的状态。</p><p>对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）；对于PetSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。</p><p>适合于PetSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务。PetSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。使用PetSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，PetSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。PetSet还只在Alpha阶段，后面的设计如何演变，我们还要继续观察。</p><p><strong>集群联邦（Federation）</strong></p><p>K8s在1.3版本里发布了beta版的Federation功能。在云计算环境中，服务的作用距离范围从近到远一般可以有：同主机（Host，Node）、跨主机同可用区（Available Zone）、跨可用区同地区（Region）、跨地区同服务商（Cloud Service Provider）、跨云平台。K8s的设计定位是单一集群在同一个地域内，因为同一个地区的网络性能才能满足K8s的调度和计算存储连接要求。而联合集群服务就是为提供跨Region跨服务商K8s集群服务而设计的。</p><p>每个K8s Federation有自己的分布式存储、API Server和Controller Manager。用户可以通过Federation的API Server注册该Federation的成员K8s Cluster。当用户通过Federation的API Server创建、更改API对象时，Federation API Server会在自己所有注册的子K8s Cluster都创建一份对应的API对象。在提供业务请求服务时，K8s Federation会先在自己的各个子Cluster之间做负载均衡，而对于发送到某个具体K8s Cluster的业务请求，会依照这个K8s Cluster独立提供服务时一样的调度模式去做K8s Cluster内部的负载均衡。而Cluster之间的负载均衡是通过域名服务的负载均衡来实现的。</p><p>所有的设计都尽量不影响K8s Cluster现有的工作机制，这样对于每个子K8s集群来说，并不需要更外层的有一个K8s Federation，也就是意味着所有现有的K8s代码和机制不需要因为Federation功能有任何变化。</p><p><strong>存储卷（Volume）</strong></p><p>K8s集群中的存储卷跟Docker的存储卷有些类似，只不过Docker的存储卷作用范围为一个容器，而K8s的存储卷的生命周期和作用范围是一个Pod。每个Pod中声明的存储卷由Pod中的所有容器共享。K8s支持非常多的存储卷类型，特别的，支持多种公有云平台的存储，包括AWS，Google和Azure云；支持多种分布式存储包括GlusterFS和Ceph；也支持较容易使用的主机本地目录hostPath和NFS。K8s还支持使用Persistent Volume Claim即PVC这种逻辑存储，使用这种存储，使得存储的使用者可以忽略后台的实际存储技术（例如AWS，Google或GlusterFS和Ceph），而将有关存储实际技术的配置交给存储管理员通过Persistent Volume来配置。</p><p>持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）<br>PV和PVC使得K8s集群具备了存储的逻辑抽象能力，使得在配置Pod的逻辑里可以忽略对实际后台存储技术的配置，而把这项配置的工作交给PV的配置者，即集群的管理者。存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由K8s集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，有K8s集群的使用者即服务的管理员来配置。</p><p><strong>节点（Node）</strong></p><p>K8s集群中的计算能力由Node提供，最初Node称为服务节点Minion，后来改名为Node。K8s集群中的Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p><p><strong>密钥对象（Secret）</strong></p><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可以避免把敏感信息明文写在配置文件里。在K8s集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例如访问AWS存储的用户名密码。为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个Secret对象，而在配置文件中通过Secret对象引用这些敏感信息。这种方式的好处包括：意图明确，避免重复，减少暴漏机会。</p><p>用户帐户（User Account）和服务帐户（Service Account）<br>顾名思义，用户帐户为人提供账户标识，而服务账户为计算机进程和K8s集群中运行的Pod提供账户标识。用户帐户和服务帐户的一个区别是作用范围；用户帐户对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的；而服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。</p><p><strong>名字空间（Namespace）</strong></p><p>名字空间为K8s集群提供虚拟的隔离作用，K8s集群初始有两个名字空间，分别是默认名字空间default和系统名字空间kube-system，除此以外，管理员可以可以创建新的名字空间满足需要。</p><p><strong>RBAC访问授权</strong></p><p>K8s在1.3版本中发布了alpha版的基于角色的访问控制（Role-based Access Control，RBAC）的授权模式。相对于基于属性的访问控制（Attribute-based Access Control，ABAC），RBAC主要是引入了角色（Role）和角色绑定（RoleBinding）的抽象概念。在ABAC中，K8s集群中的访问策略只能跟用户直接关联；而在RBAC中，访问策略可以跟某个角色关联，具体的用户在跟一个或多个角色相关联。显然，RBAC像其他新功能一样，每次引入新功能，都会引入新的API对象，从而引入新的概念抽象，而这一新的概念抽象一定会使集群服务管理和使用更容易扩展和重用。</p><p><strong>总结</strong></p><p>从K8s的系统架构、技术概念和设计理念，我们可以看到K8s系统最核心的两个设计理念：一个是容错性，一个是易扩展性。容错性实际是保证K8s系统稳定性和安全性的基础，易扩展性是保证K8s对变更友好，可以快速迭代增加新功能的基础。</p><p>从开发到运维了哈哈哈哈</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;一、Kubernetes入门&quot;&gt;&lt;a href=&quot;#一、Kubernetes入门&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="k8s" scheme="https://lincx_py.gitee.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>go开发project的一些困惑及解决措施</title>
    <link href="https://lincx_py.gitee.io/2020/05/01/godevl/"/>
    <id>https://lincx_py.gitee.io/2020/05/01/godevl/</id>
    <published>2020-05-01T15:24:42.000Z</published>
    <updated>2020-05-03T11:06:16.107Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><h2 id="GoWeb开发遇到的坑以及填坑方法"><a href="#GoWeb开发遇到的坑以及填坑方法" class="headerlink" title="GoWeb开发遇到的坑以及填坑方法"></a>GoWeb开发遇到的坑以及填坑方法</h2><h3 id="一、用户验证怎么搞？"><a href="#一、用户验证怎么搞？" class="headerlink" title="一、用户验证怎么搞？"></a>一、用户验证怎么搞？</h3><p>之前我是用cookie跟session做的登录验证，后来有一天，偶然的看到了另外之中验证机制–JWT<br>于是心血来潮，搞一波叭</p><p>于是各种碰壁，在网上学了比较多的经验。下面是一些笔记</p><p><strong>什么是JWT？</strong><br>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><p><strong>session的一些小不足</strong></p><ul><li><p>Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p></li><li><p>扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p></li><li><p>CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li></ul><p><strong>Token又是怎样呢</strong></p><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><p>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul><p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。</p><p><strong>然后怎么生成？</strong><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateToken</span><span class="params">(user *models.User)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims&#123;</span><br><span class="line"><span class="string">"username"</span>: user.Username,</span><br><span class="line"><span class="comment">//"exp":      time.Now().Add(time.Hour * 2).Unix(),// 可以添加过期时间</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> token.SignedString([]<span class="keyword">byte</span>(<span class="string">"secret"</span>)) <span class="comment">//对应的字符串请自行生成，最后足够使用加密后的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>怎么验证？</strong></p><p>这里我将它做出了拦截器<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TokenMiddleware</span><span class="params">(next http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">tokenStr := r.Header.Get(<span class="string">"Cookie"</span>)</span><br><span class="line"><span class="keyword">if</span> tokenStr == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// ResponseWithJson(w, http.StatusUnauthorized,</span></span><br><span class="line"><span class="comment">// models.Response&#123;Code: http.StatusUnauthorized, Msg: "not authorized"&#125;)</span></span><br><span class="line">http.Redirect(w,r,<span class="string">"/error"</span>,http.StatusFound)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">token, _ := jwt.Parse(tokenStr, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok &#123;</span><br><span class="line">ResponseWithJson(w, http.StatusUnauthorized,</span><br><span class="line">models.Response&#123;Code: http.StatusUnauthorized, Msg: <span class="string">"not authorized"</span>&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not authorization"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">"secret"</span>), <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> !token.Valid &#123;</span><br><span class="line"><span class="comment">// ResponseWithJson(w, http.StatusUnauthorized,</span></span><br><span class="line"><span class="comment">// models.Response&#123;Code: http.StatusUnauthorized, Msg: "not authorized"&#125;)</span></span><br><span class="line">http.Redirect(w,r,<span class="string">"/error"</span>,http.StatusFound)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next(w, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>然后问题来了</strong></p><p>怎么存token？怎么将token放进请求头？？<br>token可以保存在</p><ol><li>保存在浏览器的localstore，这个挺方便的，但是每次都要访问网页都要把它取出来加紧请求头里面，有点麻烦，对于我这个前端小白来说是个折磨，所以我放弃了。</li><li>保存在seesion里面，这个方法我还没有试过，不过应该是可以的。</li><li>保存到cookie里面，这样保存的话，每次访问它自动加入到请求头，不需要我再另外加了；但是还是有一些弊端的，这里我就不想详谈了。</li></ol><h3 id="前端的坑"><a href="#前端的坑" class="headerlink" title="前端的坑"></a>前端的坑</h3><p>现在流行前后端分离，前后端进行交互使用的是json格式的数据，这个模式在小程序开发中得到了很好的体现。那么问题来了，前端怎么将数据转换成json格式，然后发送给后端呢？我知道是用js，但是没学过啊，卑微的小白，只能再次求助百度，百度说用ajax异步请求可以，好的，我就按照这个来，但是没有啊，没有成功，我也不知道为什么，于是心里的执念，我一定要攻破它，于是又卡在这卡了几天，最后光荣妥协，选择了另外一个axios，这个用起来就顺畅多了，也推荐前端的小伙伴们使用这个给后端发送数据。</p><p>对了，还有一个坑，就是有时候你给后端发送数据，然后你前段地址栏上面在原来的基础上加了数据上去，就像表单一样，aaaa我就很烦，后端返回的响应数据想在前端显示也不行，想跳转也跳转不了，于是又开始地毯式找bug，终于经过一个晚上的摸索，发现是因为我将button放进表单里面了，导致表单重复提交？我误打误撞，将button拿到表单外面，里面运行成功！</p><h3 id="linux部署项目的坑"><a href="#linux部署项目的坑" class="headerlink" title="linux部署项目的坑"></a>linux部署项目的坑</h3><p>终于把项目的大体功能给实现了，准备linux部署一波，这时候问题又来了，程序正常运行，没有报错，但是前端的部分页面显示不出来，然后发现这些显示不了的页面都是使用了bootstrap，我就在想会不会是linux浏览器不兼容？于是，我用windows访问一下Linux的下运行的程序，发现windows的也不行，这就尴尬了，会不会只是这筐浏览器不支持而已呢？（我用的是Google Chrome）于是又用火狐访问一下，发现好像还是不行的亚子。。。会不会是静态资源路径引入的问题呢？但是我不知道咋改啊，咋改都不行，算了算了，这些显示不了的页面的css，我就用官方给的cdn吧，引入之后一运行，就正常了55555.<br>现在我还在查那个路径的问题。。。。</p><h3 id="部署到docker了"><a href="#部署到docker了" class="headerlink" title="部署到docker了"></a>部署到docker了</h3><p>不说了，直接上代码<br>第一步将程序编译，这里要注意一下，因为程序是从Windows拷贝过来的，在linux下编译的话有一些包没有下载，所以这时候要用到mod了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、go mod</span><br><span class="line">2、go build</span><br></pre></td></tr></table></figure><p></p><p>接下来要在项目根目录下生成一个docker文件,在里面写<br></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> <span class="string">"kl023011@gmail.com"</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /Users/admin/go_mod/hellodocker</span><br><span class="line">ADD . /Users/admin/go_mod/hellodocker</span><br><span class="line">RUN go build .</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT ["./hellodocker"]</span><br><span class="line">------</span><br><span class="line">FROM 母镜像</span><br><span class="line">MAINTAINER 维护者信息</span><br><span class="line">WORKDIR工作目录</span><br><span class="line">ADD 将文件复制到镜像中</span><br><span class="line">RUN 执行操作</span><br><span class="line">EXPOSE 监听端口</span><br><span class="line">ENTRYPOINT 程序入口</span><br></pre></td></tr></table></figure><p></p><p>完成了之后，将程序打包发送到云服务器，这时候在linux有一个工具scp可以直接使用了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、发送单个文件</span><br><span class="line">scp 本地文件路径 远程主机名字@地址:在远程主机保存的路径</span><br><span class="line">2、发送一个文件夹</span><br><span class="line">scp -r 本地文件路径 远程主机名字@地址:在远程主机保存的路径</span><br></pre></td></tr></table></figure><p></p><p>成功之后，使用ssh登录远程主机<br>cd 进入项目保存的路径到docker文件所在路径,下面就可以开始制作镜像了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、docker build -t 镜像名字 .</span><br></pre></td></tr></table></figure><p></p><p>docker build 构建镜像</p><p>. (点号) dockerfile目录为当前目录</p><p>当看到successfully xxxxx<br>就构建完成了</p><p>下一步，运行容器<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d 镜像名字</span><br></pre></td></tr></table></figure><p></p><p>-p 8080:8080 将宿主机（也就是本机）的8080端口映射到容器的8080端口，此处需要先确认本机的8080端口并未被占用，容器的8080端口是否在监听，阿里云主机的话要添加安全组哦</p><p>-d表示在后台运行</p><p>结束之后，在本地浏览器（windows跟linux）访问，成功！！！！！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;GoWeb开发遇到的坑以及填坑方法&quot;&gt;&lt;a href=&quot;#GoWeb开发遇到的坑以及填坑方法&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="GoWeb" scheme="https://lincx_py.gitee.io/tags/GoWeb/"/>
    
  </entry>
  
  <entry>
    <title>rails</title>
    <link href="https://lincx_py.gitee.io/2020/04/26/rails/"/>
    <id>https://lincx_py.gitee.io/2020/04/26/rails/</id>
    <published>2020-04-26T10:35:44.000Z</published>
    <updated>2020-04-26T15:27:52.544Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="Rails设计思想"><a href="#Rails设计思想" class="headerlink" title="Rails设计思想"></a>Rails设计思想</h1><h2 id="1、Rails是什么？？"><a href="#1、Rails是什么？？" class="headerlink" title="1、Rails是什么？？"></a>1、Rails是什么？？</h2><p>Rails 是使用 Ruby 语言编写的 Web 应用开发框架，目的是通过解决快速开发中的共通问题，简化 Web 应用的开发。与其他编程语言和框架相比，使用 Rails 只需编写更少代码就能实现更多功能。有经验的 Rails 程序员常说，Rails 让 Web 应用开发变得更有趣。</p><p>Rails 有自己的设计原则，认为问题总有最好的解决方法，并且有意识地通过设计来鼓励用户使用最好的解决方法，而不是其他替代方案。一旦掌握了“Rails 之道”，就可能获得生产力的巨大提升。在 Rails 开发中，如果不改变使用其他编程语言时养成的习惯，总想使用原有的设计模式，开发体验可能就不那么让人愉快了。</p><p>Rails 哲学包含两大指导思想：</p><ul><li>不要自我重复（DRY）： DRY 是软件开发中的一个原则，意思是“系统中的每个功能都要具有单一、准确、可信的实现。”。不重复表述同一件事，写出的代码才更易维护、更具扩展性，也更不容易出问题。</li><li>多约定，少配置： Rails 为 Web 应用的大多数需求都提供了最好的解决方法，并且默认使用这些约定，而不是在长长的配置文件中设置每个细节。</li></ul><h2 id="2、心法思路"><a href="#2、心法思路" class="headerlink" title="2、心法思路"></a>2、心法思路</h2><p><img src="https://upload-images.jianshu.io/upload_images/5957-7987ca4dd53446af.png?imageMogr2/auto-orient/strip|imageView2/2/w/1095/format/webp" alt="消息响应"></p><ol><li>首先你的浏览器访问网页的时候, 比如本地的 0.0.0.0, 浏览器会向 Rails 后台发送 0.0.0.0 的 GET 请求</li><li>路由器 (Router) 会直接返回路由中 root 路径对应的页面, 这就是我们访问网站的首页</li><li>在首页中点击 &lt;a&gt; 标签的连接, 浏览器从 &lt;a&gt;标签中提取 href 路径继续向 Rails 发送 HTTP 请求</li><li>路由器根据 href 请求的路径和路由表, 找到相同名字的控制器(Controller), 并调用控制器中对应的动作 (index, show, edit, update, destroy) 函数去执行</li><li>控制器动作函数一般会查询模型(Model)的数据, 根据动作函数中的逻辑来产生不同的请求响应 (JSON, JS 或者 html.erb 模板文件)</li><li>浏览器根据控制器返回的请求响应来更改当前的页面, 以完成一次完整的消息循环处理</li></ol><p><strong>Rails再控制器respond_to处理响应的四种方式：</strong></p><ol><li>第一种是直接返回html.erb文件，html.erb文件会根据填充数据生成新的html页面（这个在go中就是template的渲染了吧？）</li><li>第二种返回js.erb文件，根据填充的数据生成新的js文件直接在当前页面中执行代码操作DOM元素</li><li>第三种返回json数据给ajax，由浏览器中的ajax的js回调来处理返回的json操作，并操作当前页面的DOM元素</li><li>最后是用redirect_to_new_path转到新页面</li></ol><h2 id="3、从-Restful-的角度打通路由、控制器、视图"><a href="#3、从-Restful-的角度打通路由、控制器、视图" class="headerlink" title="3、从 Restful 的角度打通路由、控制器、视图"></a>3、从 Restful 的角度打通路由、控制器、视图</h2><p>REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。</p><p>为啥要用api呢？因为api把web应用的功能封装了起来，有利于前后端分离。另外如果前端是一个客户端（iOS、Android）或者微信小程序，那api就是为客户端提供数据、操作数据的接口。</p><p>采用HTTP协议规定的GET、POST、PUT、DELETE动作处理资源的增删改查<br><img src="https://upload-images.jianshu.io/upload_images/3315001-5ee6251da39be1d2.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp" alt=""></p><p><strong>Restful</strong><br>架构是对MVC架构改进后所形成的一种架构，通过使用事先定义好的接口与不同的服务联系起来。在RESTful架构中，浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作。因此，RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。</p><p>RESTful架构将服务器分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。</p><p>符合REST约束风格和原则的应用程序或设计就是RESTful.下面是个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/emp/<span class="number">1</span>  HTTP GET      查询id=<span class="number">1</span>的emp</span><br><span class="line"></span><br><span class="line">/emp/<span class="number">1</span>  HTTP DELETE    删除id=<span class="number">1</span>的emp,实验中直接删除会报<span class="number">405</span>错误，但是采用$.ajax异步删除就没问题</span><br><span class="line"></span><br><span class="line">/emp/<span class="number">1</span>  HTTP PUT    跟新emp</span><br><span class="line"></span><br><span class="line">/emp/add  HTTP POST     新增emp</span><br></pre></td></tr></table></figure><p>没学过JavaScript，就上网找了一下网页怎么给后端发请求<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax( &#123;  </span><br><span class="line">        type : <span class="string">"DELETE"</span>,  </span><br><span class="line">        url : <span class="string">"/spring_crud_restful/emp/deleteEmp/"</span> + id,  </span><br><span class="line">        dataType : <span class="string">"json"</span>,  </span><br><span class="line">        success : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;  </span><br><span class="line">            alert(data);  </span><br><span class="line">            location.href = <span class="string">"/spring_crud_restful/emp/listEmp/1"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p></p><p>······改天得学一下ajax，测试api用到。。。。</p><p>本文部分参考<br>链接：<a href="https://www.jianshu.com/p/c9cd8062cf35" target="_blank" rel="noopener">https://www.jianshu.com/p/c9cd8062cf35</a></p><h2 id="MVC架构（Module-View-Control）"><a href="#MVC架构（Module-View-Control）" class="headerlink" title="MVC架构（Module-View-Control）"></a>MVC架构（Module-View-Control）</h2><p><img src="https://images2018.cnblogs.com/blog/1301998/201806/1301998-20180613152430915-1860548757.png" alt=""></p><ol><li>Module 负责维持应用的状态。有时候这种状态是短暂的，只在用户的几次操作之间存在，有时候这种状态 是持久的，需要将其保存在应用程序之外（通常是datebase）; 模型携带着数据，但不止是数据；它还负责执行施加于这些数据上的业务规则——即相应的约束条件，以确保数据操作的正确性。所以 模型不仅是数据的容器，还是数据的监护者；</li><li>View 负责生成用户界面——通常会根据模型中的数据而显示相应的界面设计（就是我们在浏览器中看到的内容;</li><li>Control 负责协调这个web应用的运作、接受来自外部的事件和请求、与模型进行交互，并将合适的页面（视图）显示给用户;</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Rails设计思想&quot;&gt;&lt;a href=&quot;#Rails设计思想&quot; class=&quot;headerlink&quot; title=&quot;Rails设计思想
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="GoWeb" scheme="https://lincx_py.gitee.io/tags/GoWeb/"/>
    
  </entry>
  
  <entry>
    <title>Quad Trees</title>
    <link href="https://lincx_py.gitee.io/2020/04/16/ACM-lectrue7/"/>
    <id>https://lincx_py.gitee.io/2020/04/16/ACM-lectrue7/</id>
    <published>2020-04-16T15:36:52.000Z</published>
    <updated>2020-04-16T15:44:28.631Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h1 id="四分树"><a href="#四分树" class="headerlink" title="四分树"></a>四分树</h1><p>题目描述：</p><p>A binary image, such as the one shown in Figure 2(a), is usually represented as an array of binary entries, i.e., each entry of the array has value 0 or 1. Figure 2(b) shows the array that represents the binary image in Figure 2(a). To store the binary image of Figure 2(b), the so-called quad tree partition is usually used. For an N N array, N &lt;= 512 and N = 2^i for some positive integer i, if the entries do not have the same value, then it is partitioned into four N/2 N/2 arrays, as shown in Figure 2(c). If an N/2N/2 array does not have the same binary value, such as the upper right and lower right N/2N/2 arrays in Figure 2(c), then we can divide it into four N/4N/4 arrays again. These N/4N/4 arrays in turn can also, if needed, be divided into four N/8 N/8 arrays, etc.. The quad tree partition is completed when the whole array is partitioned into arrays of various size in which each array contains only one binary value. Figure 2(c) contains the arrays after the quad tree partition is completed.</p><p><img src="https://ae01.alicdn.com/kf/H59df1ececb404c808b3d36260ab571e47.png" alt=""></p><p>Instead of storing the binary image of Figure 2(a), we only need to store the quad tree in the form as Figure 2(d) which is encoded from Figure 2(c). In Figure 2(d), each node represents an array of Figure 2(c) in which the root node represents the original array. If the value of a node in the tree is 1, then it means that its corresponding array needs to be decomposed into four smaller arrays. Otherwise, a node will have a pair of values and the first one is 0. It means that its corresponding array is not necessary to decompose any more. In this case, the second value is 0 (respectively, 1) to indicate that all the entries in the array are 0 (respectively, 1). Thus, we only need to store the tree of Figure 2(d) to replace storing the binary image of Figure 2(a). The way to store the tree of Figure 2(d) can be represented by the following code:</p><p>(1)(0,0)(1)(0,1)(1)(0,0)(0,1)(1)(0,0)(0,0)(0,0)(0,1)(0,1)(0,0)(0,1)(0,0)(0,1).</p><p>This code is just to list the values of the nodes from the root to leaves and from left to right in each level. Deleting the parentheses and commas, we can obtain a binary number 100101100011000000010100010001 which is equal to 258C0511 in hexadecimal. You are asked to design a program for finding the resulting hexadecimal value for each given image.</p><p><strong>Input</strong></p><p>There is an integer number k, 1 &lt;= k &lt;= 100, in the first line to indicate the number of test cases. In each test case, the first line is also a positive integer N indicating that the binary image is an N N array, where N &lt;= 512 and N = 2^i for some positive integer i. Then, an N N binary array is followed in which at least one blank is between any two elements.</p><p><strong>Output</strong></p><p>The bit stream (in hexadecimal) used to code each input array.</p><p><strong>Sample Input</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">4</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">1 1 0 0</span><br><span class="line">1 1 0 0</span><br><span class="line">8</span><br><span class="line">0 0 0 0 0 0 1 1</span><br><span class="line">0 0 0 0 0 0 1 1</span><br><span class="line">0 0 0 0 0 1 0 0</span><br><span class="line">0 0 0 0 0 1 0 0</span><br><span class="line">1 1 1 1 0 0 0 0</span><br><span class="line">1 1 1 1 0 0 0 0</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure><p></p><p><strong>Sample Output</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">114</span><br><span class="line">258C0511</span><br></pre></td></tr></table></figure><p></p><p>代码：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">quadtree</span>&#123;</span><span class="comment">//四分树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> value[<span class="number">3</span>];<span class="comment">//"00","01","1"</span></span><br><span class="line">    quadtree *child[<span class="number">4</span>];</span><br><span class="line">    quadtree()&#123;<span class="comment">//初始化</span></span><br><span class="line">        child[<span class="number">0</span>]=child[<span class="number">1</span>]=child[<span class="number">2</span>]=child[<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> quadtree&amp; p)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(value,<span class="string">"1"</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(value,p.value)!=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">quadtree* head;</span><br><span class="line"><span class="keyword">char</span> MAP[<span class="number">520</span>][<span class="number">520</span>],ans[<span class="number">10000</span>],str[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> N,a[<span class="number">2500</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;MAP[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str[<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">quadtree *<span class="title">DFS</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">1</span>;<span class="comment">//表示四个孩子是否相等</span></span><br><span class="line">    quadtree* temp=<span class="keyword">new</span> quadtree;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//value值为"00","01","1",00表示0,01表示1,1表示混合点</span></span><br><span class="line">        temp-&gt;value[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">        temp-&gt;value[<span class="number">1</span>]=<span class="string">'0'</span>+MAP[r][c];</span><br><span class="line">        temp-&gt;value[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    len /= <span class="number">2</span>;</span><br><span class="line">    temp-&gt;child[<span class="number">0</span>]=DFS(r,c,len);</span><br><span class="line">    temp-&gt;child[<span class="number">1</span>]=DFS(r,c+len,len);</span><br><span class="line">    temp-&gt;child[<span class="number">2</span>]=DFS(r+len,c,len);</span><br><span class="line">    temp-&gt;child[<span class="number">3</span>]=DFS(r+len,c+len,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(*temp-&gt;child[<span class="number">0</span>] == *temp-&gt;child[i]))&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;<span class="comment">//四个孩子都相等,合并</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">delete</span> temp-&gt;child[i];</span><br><span class="line">            temp-&gt;child[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(temp-&gt;value,<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funtion</span><span class="params">(<span class="keyword">char</span> sl[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        sum=sum*<span class="number">2</span>+sl[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%OX"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lectureOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,slen,j;</span><br><span class="line">    quadtree* temp;</span><br><span class="line">    <span class="built_in">queue</span>&lt;quadtree*&gt; q;</span><br><span class="line">    q.push(head);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">strcat</span>(ans,temp-&gt;value);<span class="comment">//串连接</span></span><br><span class="line">        <span class="keyword">if</span>(!(temp-&gt;child[<span class="number">0</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                q.push(temp-&gt;child[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    slen=<span class="built_in">strlen</span>(ans);</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>,jj;</span><br><span class="line">    <span class="keyword">if</span>(slen%<span class="number">4</span>!=<span class="number">0</span>)&#123;<span class="comment">//不能刚好四个四个一组</span></span><br><span class="line">        i=slen%<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>-i;j++)str[j]=<span class="number">0</span>;<span class="comment">//余数为1，需要补3个零；余数为2需要补2个....</span></span><br><span class="line">        <span class="keyword">for</span>(jj=j;jj&lt;<span class="number">4</span>;jj++)str[jj]=ans[pos++]-<span class="string">'0'</span>;</span><br><span class="line">        funtion(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=pos;i&lt;slen;i+=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">            str[j]=ans[i+j]-<span class="string">'0'</span>;</span><br><span class="line">            funtion(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;t;u++)&#123;</span><br><span class="line">        init();</span><br><span class="line">        head=DFS(<span class="number">0</span>,<span class="number">0</span>,N);</span><br><span class="line">        lectureOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;四分树&quot;&gt;&lt;a href=&quot;#四分树&quot; class=&quot;headerlink&quot; title=&quot;四分树&quot;&gt;&lt;/a&gt;四分树&lt;/h1&gt;&lt;p&gt;题
      
    
    </summary>
    
      <category term="c/c++" scheme="https://lincx_py.gitee.io/categories/c-c/"/>
    
    
      <category term="ACM" scheme="https://lincx_py.gitee.io/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>goredis</title>
    <link href="https://lincx_py.gitee.io/2020/04/16/goredis/"/>
    <id>https://lincx_py.gitee.io/2020/04/16/goredis/</id>
    <published>2020-04-16T05:13:39.000Z</published>
    <updated>2020-04-16T07:02:50.117Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><h1 id="Go-redis"><a href="#Go-redis" class="headerlink" title="Go redis"></a>Go redis</h1><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>redis 是一个 key-value 存储系统。和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string (字符串)、list (链表)、set (集合 ) 和 zset (有序集合)。</p><p>目前应用 redis 最广泛的应该是新浪微博平台，其次还有 Facebook 收购的图片社交网站 instagram。以及其他一些有名的 互联网企业</p><p>在找golang redis驱动看网上很多网友都推荐redisgo<br>所以就用redisgo叭<br>一些知识结构<br><img src="https://upload-images.jianshu.io/upload_images/5022741-2f9c9daace6eb0a6.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt=""><br>提供给开发者使用的内容</p><ol><li>变量</li><li>常量</li><li>新类型</li><li>接口</li><li>结构体</li><li>函数</li></ol><p><strong>1、变量</strong></p><p>var ErrNil = errors.New(“redigo: nil returned”)</p><p><strong>2、常量</strong><br><strong>3、新类型</strong></p><p>（1）type Args []interface{}</p><p>（2）type Error string</p><p><strong>4、接口</strong><br>（1）Conn</p><p>（2）ConnWithTimeout</p><p>（3）Scanner</p><p>（4）Argument</p><p><strong>5、结构体</strong></p><p>（1）DialOption</p><p>（2）Pool</p><p>（3）PoolStats</p><p>（4）Subscription</p><p>（5）PubSubConn</p><p>（6）Message</p><p>（7）Script</p><p>（8）Pong</p><p><strong>6、函数</strong></p><ul><li>（1）func NewPool(newFn func() (Conn, error), maxIdle int) *Pool</li><li>（2）func NewScript(keyCount int, src string) *Script</li><li>（3）func NewLoggingConn(conn Conn, logger *log.Logger, prefix string) Conn</li><li>（4）func NewLoggingConnFilter(conn Conn, logger log.Logger, prefix string, skip func(cmdName string) bool) Conn</li><li>（5）func DoWithTimeout(c Conn, timeout time.Duration, cmd string, args …interface{}) (interface{}, error)</li><li>（6）func DoWithTimeout(c Conn, timeout time.Duration, cmd string, args …interface{}) (interface{}, error)</li><li>（7）func Int(reply interface{}, err error) (int, error)</li><li>（8）func Int64(reply interface{}, err error) (int64, error)</li><li>（9）func Uint64(reply interface{}, err error) (uint64, error)</li><li>（10）func Float64(reply interface{}, err error) (float64, error)</li><li>（11）func String(reply interface{}, err error) (string, error)</li><li>（12）func Bytes(reply interface{}, err error) ([]byte, error)</li><li>（13）func Bool(reply interface{}, err error) (bool, error)</li><li>（14）func MultiBulk(reply interface{}, err error) ([]interface{}, error)</li><li>（15）func Values(reply interface{}, err error) ([]interface{}, error)</li><li>（16）func Float64s(reply interface{}, err error) ([]float64, error)</li><li>（17）func Strings(reply interface{}, err error) ([]string, error)</li><li>（18）func ByteSlices(reply interface{}, err error) ([][]byte, error)</li><li>（19）func Int64s(reply interface{}, err error) ([]int64, error)</li><li>（20）func Ints(reply interface{}, err error) ([]int, error)</li><li>（21）func StringMap(result interface{}, err error) (map[string]string, error)</li><li>（22）func IntMap(result interface{}, err error) (map[string]int, error)</li><li>（23）func Int64Map(result interface{}, err error) (map[string]int64, error)</li><li>（24）func Positions(result interface{}, err error) ([][2]float64, error)</li><li>（25）func DialTimeout(network, address string, connectTimeout, readTimeout, writeTimeout time.Duration) (Conn, error)</li><li>（26）func DialReadTimeout(d time.Duration) DialOption</li><li>（27）func DialWriteTimeout(d time.Duration) DialOption</li><li>（28）func DialConnectTimeout(d time.Duration) DialOption</li><li>（29）func DialKeepAlive(d time.Duration) DialOption</li><li>（30）func DialNetDial(dial func(network, addr string) (net.Conn, error)) DialOption</li><li>（31）func DialDatabase(db int) DialOption</li><li>（32）func DialPassword(password string) DialOption</li><li>（33）func DialTLSConfig(c *tls.Config) DialOption</li><li>（34）func DialTLSSkipVerify(skip bool) DialOption</li></ul><p>话不多说，上代码：</p><h3 id="1、连接"><a href="#1、连接" class="headerlink" title="1、连接"></a>1、连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gomodule/redigo/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//连接redis</span></span><br><span class="line">c,err:=redis.Dial(<span class="string">"tcp"</span>,<span class="string">"120.78.6.205:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Connect to redis error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"><span class="comment">//读写（不会过期）</span></span><br><span class="line">_,err=c.Do(<span class="string">"SET"</span>,<span class="string">"mykey"</span>,<span class="string">"superlin"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis set error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">username,err:=redis.String(c.Do(<span class="string">"GET"</span>,<span class="string">"mykey"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis get error"</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(username)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、设置过期"><a href="#2、设置过期" class="headerlink" title="2、设置过期"></a>2、设置过期</h3><p>上面例子SET参数不会过期，想要设置过期，添加SET的附加参数化即可<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gomodule/redigo/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//连接redis</span></span><br><span class="line">c,err:=redis.Dial(<span class="string">"tcp"</span>,<span class="string">"120.78.6.205:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Connect to redis error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line">_,err=c.Do(<span class="string">"SET"</span>,<span class="string">"mykey"</span>,<span class="string">"superlin"</span>,<span class="string">"EX"</span>,<span class="string">"5"</span>)<span class="comment">//设置5秒过期</span></span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis set error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">username,err:=redis.String(c.Do(<span class="string">"GET"</span>,<span class="string">"mykey"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis get error"</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">8</span>*time.Second)</span><br><span class="line">username,err=redis.String(c.Do(<span class="string">"GET"</span>,<span class="string">"mykey"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis get error"</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(username)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置过期时间为24小时  </span></span><br><span class="line">n, _ := rs.Do(<span class="string">"EXPIRE"</span>, key, <span class="number">24</span>*<span class="number">3600</span>)  </span><br><span class="line"><span class="keyword">if</span> n == <span class="keyword">int64</span>(<span class="number">1</span>) &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"success"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">还可以通过这种方法来设置过期事件</span><br></pre></td></tr></table></figure><p></p><h3 id="3、检测值是否存在"><a href="#3、检测值是否存在" class="headerlink" title="3、检测值是否存在"></a>3、检测值是否存在</h3><p>EXISTS key<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gomodule/redigo/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//连接redis</span></span><br><span class="line">c,err:=redis.Dial(<span class="string">"tcp"</span>,<span class="string">"120.78.6.205:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Connect to redis error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">_,err=c.Do(<span class="string">"SET"</span>,<span class="string">"mykey"</span>,<span class="string">"superlin"</span>,<span class="string">"EX"</span>,<span class="string">"5"</span>)<span class="comment">//设置5秒过期</span></span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis set error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">is_key_exist,err:=redis.Bool(c.Do(<span class="string">"EXISTS"</span>,<span class="string">"mykey"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"error:"</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"exits or not:%v\n"</span>,is_key_exist)</span><br><span class="line">&#125;</span><br><span class="line">username,err:=redis.String(c.Do(<span class="string">"GET"</span>,<span class="string">"mykey"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis get error"</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(username)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="4、删除操作"><a href="#4、删除操作" class="headerlink" title="4、删除操作"></a>4、删除操作</h3><p>DEL key[key…]<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gomodule/redigo/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//连接redis</span></span><br><span class="line">c,err:=redis.Dial(<span class="string">"tcp"</span>,<span class="string">"120.78.6.205:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Connect to redis error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"><span class="comment">//读写（不会过期）</span></span><br><span class="line">_,err=c.Do(<span class="string">"SET"</span>,<span class="string">"mykey"</span>,<span class="string">"superlin"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis set error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">is_key_exist,err:=redis.Bool(c.Do(<span class="string">"EXISTS"</span>,<span class="string">"mykey"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"error:"</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"exits or not:%v\n"</span>,is_key_exist)</span><br><span class="line">&#125;</span><br><span class="line">username,err:=redis.String(c.Do(<span class="string">"GET"</span>,<span class="string">"mykey"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis get error"</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(username)</span><br><span class="line">&#125;</span><br><span class="line">_,err=c.Do(<span class="string">"DEL"</span>,<span class="string">"mykey"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis delete error:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">username,err=redis.String(c.Do(<span class="string">"GET"</span>,<span class="string">"mykey"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"redis get error"</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(username)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="5、读写json到redis"><a href="#5、读写json到redis" class="headerlink" title="5、读写json到redis"></a>5、读写json到redis</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gomodule/redigo/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//连接redis</span></span><br><span class="line">c,err:=redis.Dial(<span class="string">"tcp"</span>,<span class="string">"120.78.6.205:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Connect to redis error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line">key:=<span class="string">"profile"</span></span><br><span class="line">imap:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"username"</span>:<span class="string">"666"</span>,<span class="string">"phone"</span>:<span class="string">"1233333"</span>&#125;</span><br><span class="line">value,err:=json.Marshal(imap)<span class="comment">//将map转换为json格式</span></span><br><span class="line">n,err:=c.Do(<span class="string">"SETNX"</span>,key,value)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n==<span class="keyword">int64</span>(<span class="number">1</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">"SET success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> imapGet <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">valueGet,err:=redis.Bytes(c.Do(<span class="string">"GET"</span>,key))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">errShal:=json.Unmarshal(valueGet,&amp;imapGet)</span><br><span class="line"><span class="keyword">if</span> errShal!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(errShal)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(imapGet[<span class="string">"username"</span>])</span><br><span class="line">fmt.Println(imapGet)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、列表操作"><a href="#6、列表操作" class="headerlink" title="6、列表操作"></a>6、列表操作</h3><p>redis命令：<br></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH runoobkey redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH runoobkey mongodb</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH runoobkey mysql</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE runoobkey <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"mysql"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis</span></span><br></pre></td></tr></table></figure><p></p><p>使用go操作<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/gomodule/redigo/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//连接redis</span></span><br><span class="line">c,err:=redis.Dial(<span class="string">"tcp"</span>,<span class="string">"120.78.6.205:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Connect to redis error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line">slice:=[]<span class="keyword">string</span>&#123;<span class="string">"11"</span>,<span class="string">"222"</span>,<span class="string">"ssss"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _,str:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">_,err=c.Do(<span class="string">"LPUSH"</span>,<span class="string">"runoobkey"</span>,str)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">values,err:=redis.Values(c.Do(<span class="string">"LRANGE"</span>,<span class="string">"runoobkey"</span>,<span class="string">"0"</span>, <span class="string">"10"</span>))</span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> values&#123;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(v.([]<span class="keyword">byte</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Hash表操作"><a href="#Hash表操作" class="headerlink" title="Hash表操作"></a>Hash表操作</h3><h4 id="hset-hget"><a href="#hset-hget" class="headerlink" title="hset/hget"></a>hset/hget</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">key := <span class="string">"abc"</span></span><br><span class="line">_,err := conn.Do(<span class="string">"hset"</span>,<span class="string">"books"</span>,key,<span class="string">"this is a test!"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"set value faild,eror:%vn"</span>,err)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data,err := redis.String(conn.Do(<span class="string">"hget"</span>,<span class="string">"books"</span>,key))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"get faild,err:%vn"</span>,err)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"key:%s, value:%vn"</span>,key,data)</span><br></pre></td></tr></table></figure><h4 id="hmset-hmget"><a href="#hmset-hmget" class="headerlink" title="hmset/hmget"></a>hmset/hmget</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_, err = c.Do(<span class="string">"hmset"</span>, <span class="string">"myhash"</span>, <span class="string">"bike2"</span>, <span class="string">"bluegogo"</span>, <span class="string">"bike3"</span>, <span class="string">"xiaoming"</span>, <span class="string">"bike4"</span>, <span class="string">"xiaolan"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hmset error"</span>, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    value, err := redis.Values(c.Do(<span class="string">"hmget"</span>, <span class="string">"myhash"</span>, <span class="string">"bike1"</span>, <span class="string">"bike2"</span>, <span class="string">"bike3"</span>, <span class="string">"bike4"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"hmget failed"</span>, err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"hmget myhash's element :"</span>)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> value &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s "</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hincrby"><a href="#hincrby" class="headerlink" title="hincrby"></a>hincrby</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_, err = c.Do(<span class="string">"hmset"</span>, <span class="string">"myhash"</span>, <span class="string">"bike2"</span>, <span class="string">"bluegogo"</span>, <span class="string">"bike3"</span>, <span class="string">"xiaoming"</span>, <span class="string">"bike4"</span>, <span class="string">"xiaolan"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hmset error"</span>, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    value, err := redis.Values(c.Do(<span class="string">"hmget"</span>, <span class="string">"myhash"</span>, <span class="string">"bike1"</span>, <span class="string">"bike2"</span>, <span class="string">"bike3"</span>, <span class="string">"bike4"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"hmget failed"</span>, err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"hmget myhash's element :"</span>)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> value &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s "</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis并发"><a href="#Redis并发" class="headerlink" title="Redis并发"></a>Redis并发</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">key := <span class="string">"abc"</span></span><br><span class="line">   key1 := <span class="string">"def"</span></span><br><span class="line">   _,err := conn.Do(<span class="string">"mset"</span>,key,key1)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"set value faild,eror:%vn"</span>,err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//多值操作返回的数据用strings接收</span></span><br><span class="line">   data,err := redis.Strings(conn.Do(<span class="string">"mget"</span>,key,key1))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"get faild,err:%vn"</span>,err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//循环取值</span></span><br><span class="line">   <span class="keyword">for</span> _,val := <span class="keyword">range</span> data &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"key:%s, value:%vn"</span>,key,val)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="设置队列"><a href="#设置队列" class="headerlink" title="设置队列"></a>设置队列</h3><p>发布订阅<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_,err := conn.Do(<span class="string">"lpush"</span>,<span class="string">"book_list"</span>,<span class="string">"this is a test!"</span>,<span class="string">"daadada"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"lpush value faild,eror:%vn"</span>,err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   data,err := redis.String(conn.Do(<span class="string">"rpop"</span>,<span class="string">"book_list"</span>))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"get faild,err:%vn"</span>,err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"value:%sn"</span>,data)</span><br></pre></td></tr></table></figure><p></p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>请求/响应服务可以实现持续处理新请求，即使客户端没有准备好读取旧响应。这样客户端可以发送多个命令到服务器而无需等待响应，最后在一次读取多个响应。这就是管道化(pipelining)，这个技术在多年就被广泛使用了。距离，很多POP3协议实现已经支持此特性，显著加速了从服务器下载新邮件的过程。</p><p>连接支持使用Send()，Flush()，Receive()方法支持管道化操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Send(commandName <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">Flush() error</span><br><span class="line">Receive() (reply <span class="keyword">interface</span>&#123;&#125;, err error)</span><br></pre></td></tr></table></figure><p>Send向连接的输出缓冲中写入命令。Flush将连接的输出缓冲清空并写入服务器端。Recevie按照FIFO顺序依次读取服务器的响应。下例展示了一个简单的管道：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c.Send(<span class="string">"SET"</span>, <span class="string">"foo"</span>, <span class="string">"bar"</span>)</span><br><span class="line">c.Send(<span class="string">"GET"</span>, <span class="string">"foo"</span>)</span><br><span class="line">c.Flush()</span><br><span class="line">c.Receive() <span class="comment">// reply from SET</span></span><br><span class="line">v, err = c.Receive() <span class="comment">// reply from GET</span></span><br></pre></td></tr></table></figure><p></p><p>待续….</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Go-redis&quot;&gt;&lt;a href=&quot;#Go-redis&quot; class=&quot;headerlink&quot; title=&quot;Go redis&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="学习笔记" scheme="https://lincx_py.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go web学习</title>
    <link href="https://lincx_py.gitee.io/2020/04/14/GoWeb1/"/>
    <id>https://lincx_py.gitee.io/2020/04/14/GoWeb1/</id>
    <published>2020-04-14T05:24:58.000Z</published>
    <updated>2020-04-16T08:23:38.625Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --><h1 id="Go-Web开发"><a href="#Go-Web开发" class="headerlink" title="Go Web开发"></a>Go Web开发</h1><h2 id="Web工作方式"><a href="#Web工作方式" class="headerlink" title="Web工作方式"></a>Web工作方式</h2><p>我们平时浏览网页的时候，会打开浏览器，输入网址后按下回车键，然后就会显示出你想要浏览的内容。在这个看似简单的用户行为背后，到底隐藏了些什么呢？</p><p>对于普通的上网过程，系统其实是这样做的：浏览器本身是一个客户端，当你输入 URL 的时候，首先浏览器会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过 IP 地址找到 IP 对应的服务器后，要求建立 TCP 连接，等浏览器发送完 HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回 HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个 Response 包里的主体（body），等收到全部的内容随后断开与该服务器之间的 TCP 连接。</p><p>一个 Web 服务器也被称为 HTTP 服务器，它通过 HTTP 协议与客户端通信。这个客户端通常指的是 Web 浏览器 (其实手机端客户端内部也是浏览器实现的)。<br><img src="https://cdn.learnku.com/build-web-application-with-golang/images/3.1.web2.png?raw=true" alt=""><br>Web 服务器的工作原理可以简单地归纳为：</p><ul><li>客户机通过 TCP/IP 协议建立到服务器的 TCP 连接</li><li>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档</li><li>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理 “动态内容”，并将处理得到的数据返回给客户端</li><li>客户机与服务器断开。由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果</li><li>一个简单的 HTTP 事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。<h3 id="URL与DNS"><a href="#URL与DNS" class="headerlink" title="URL与DNS"></a>URL与DNS</h3></li></ul><p>我们浏览网页都是通过 URL 访问的，那么 URL 到底是怎么样的呢？</p><p>URL (Uniform Resource Locator) 是 “统一资源定位符” 的英文缩写，用于描述一个网络上的资源，基本格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scheme://host[:port#]/path/.../[?query-string][#anchor]</span><br><span class="line">scheme         指定底层使用的协议(例如：http, https, ftp)</span><br><span class="line">host           HTTP 服务器的 IP 地址或者域名</span><br><span class="line">port#          HTTP 服务器的默认端口是 80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/</span><br><span class="line">path           访问资源的路径</span><br><span class="line">query-string   发送给 http 服务器的数据</span><br><span class="line">anchor         锚</span><br></pre></td></tr></table></figure><p>DNS (Domain Name System) 是 “域名系统” 的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于 TCP/IP 网络，它从事将主机名或域名转换为实际 IP 地址的工作。DNS 就是这样的一位 “翻译官”，它的基本工作原理可用下图来表示。</p><p><img src="https://cdn.learnku.com/build-web-application-with-golang/images/3.1.dns_hierachy.png?raw=true" alt=""><br>更详细的 DNS 解析的过程如下，这个过程有助于我们理解 DNS 的工作模式</p><ol><li><p>在浏览器中输入 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。</p></li><li><p>如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li><li><p>如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></li><li><p>如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。</p></li><li><p>如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 “根 DNS 服务器”，“根 DNS 服务器” 收到请求后会判断这个域名 (.com) 是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责 .com 域的这台服务器。这台负责 .com 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com 域的下一级 DNS 服务器地址 (qq.com) 给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，重复上面的动作，进行查询，直至找到 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 主机。</p></li><li><p>如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上级，以此循环。不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。</p></li></ol><p><img src="https://cdn.learnku.com/build-web-application-with-golang/images/3.1.dns_inquery.png?raw=true" alt=""></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP 协议是 Web 工作的核心，所以要了解清楚 Web 的工作方式就需要详细的了解清楚 HTTP 是怎么样工作的。</p><p>HTTP 是一种让 Web 服务器与浏览器 (客户端) 通过 Internet 发送与接收数据的协议，它建立在 TCP 协议之上，一般采用 TCP 的 80 端口。它是一个请求、响应协议 – 客户端发出一个请求，服务器响应这个请求。在 HTTP 中，客户端总是通过建立一个连接与发送一个 HTTP 请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击 “停止” 键来中断文件的下载，关闭与服务器的 HTTP 连接。</p><p>HTTP 协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对 HTTP 服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web 程序引入了 Cookie 机制来维护连接的可持续状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP 协议是建立在 TCP 协议之上的，因此 TCP 攻击一样会影响 HTTP 的通讯，例如比较常见的一些攻击：SYN Flood 是当前最流行的 DoS（拒绝服务攻击）与 DdoS（分布式拒绝服务攻击）的方式之一，这是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。</span><br></pre></td></tr></table></figure><h4 id="HTTP-请求包（浏览器信息）"><a href="#HTTP-请求包（浏览器信息）" class="headerlink" title="HTTP 请求包（浏览器信息）"></a>HTTP 请求包（浏览器信息）</h4><p>我们先来看看 Request 包的结构，Request 包分为 3 部分，第一部分叫 Request line（请求行）, 第二部分叫 Request header（请求头）, 第三部分是 body（主体）。header 和 body 之间有个空行，请求包的例子所示:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /domains/example/ HTTP/1.1      // 请求行: 请求方法 请求 URI HTTP 协议/协议版本</span><br><span class="line">Host：www.iana.org               // 服务端的主机名</span><br><span class="line">User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4          // 浏览器信息</span><br><span class="line">Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8  // 客户端能接收的 mine</span><br><span class="line">Accept-Encoding：gzip,deflate,sdch       // 是否支持流压缩</span><br><span class="line">Accept-Charset：UTF-8,*;q=0.5        // 客户端字符编码集</span><br><span class="line">// 空行,用于分割请求头和消息体</span><br><span class="line">// 消息体,请求资源参数,例如 POST 传递的参数</span><br></pre></td></tr></table></figure><p></p><p>HTTP 协议定义了很多与服务器交互的请求方法，最基本的有 4 种，分别是 GET, POST, PUT, DELETE。一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET, POST, PUT, DELETE 就对应着对这个资源的查，增，改，删 4 个操作。我们最常见的就是 GET 和 POST 了。GET 一般用于获取 / 查询资源信息，而 POST 一般用于更新资源信息。</p><h4 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别:"></a>GET 和 POST 的区别:</h4><p>我们可以看到 GET 请求消息体为空，POST 请求带有消息体。<br>GET 提交的数据会放在 URL 之后，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连，如 EditPosts.aspx?name=test1&amp;id=123456。POST 方法是把提交的数据放在 HTTP 包的 body 中。<br>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。<br>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p><h4 id="HTTP-响应包（服务器信息）"><a href="#HTTP-响应包（服务器信息）" class="headerlink" title="HTTP 响应包（服务器信息）"></a>HTTP 响应包（服务器信息）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK                     // 状态行</span><br><span class="line">Server: nginx/1.0.8                 // 服务器使用的 WEB 软件名及版本</span><br><span class="line">Date: Tue, 30 Oct 2012 04:14:25 GMT     // 发送时间</span><br><span class="line">Content-Type: text/html             // 服务器发送信息的类型</span><br><span class="line">Transfer-Encoding: chunked          // 表示发送 HTTP 包是分段发的</span><br><span class="line">Connection: keep-alive              // 保持连接状态</span><br><span class="line">Content-Length: 90                  // 主体内容长度</span><br><span class="line">// 空行 用来分割消息头和主体</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... // 消息体</span><br></pre></td></tr></table></figure><p>Response 包中的第一行叫做状态行，由 HTTP 协议版本号， 状态码， 状态消息三部分组成。</p><p>状态码用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response。HTTP/1.1 协议中定义了 5 类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p><ul><li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li><li>2XX 成功 - 表示请求已被成功接收，理解，接受</li><li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li><li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li><li>5XX 服务器端错误 - 服务器未能实现合法的请求</li></ul><h2 id="go中Web工作过程"><a href="#go中Web工作过程" class="headerlink" title="go中Web工作过程"></a>go中Web工作过程</h2><h3 id="web工作方式的几个概念"><a href="#web工作方式的几个概念" class="headerlink" title="web工作方式的几个概念"></a>web工作方式的几个概念</h3><p>以下均是服务器端的几个概念</p><p>Request：用户请求的信息，用来解析用户的请求信息，包括 post、get、cookie、url 等信息</p><p>Response：服务器需要反馈给客户端的信息</p><p>Conn：用户的每次请求链接</p><p>Handler：处理请求和生成返回信息的处理逻辑</p><h3 id="分析http包运行机制"><a href="#分析http包运行机制" class="headerlink" title="分析http包运行机制"></a>分析http包运行机制</h3><p><img src="https://cdn.learnku.com/build-web-application-with-golang/images/3.3.http.png?raw=true" alt=""></p><ol><li><p>创建 Listen Socket, 监听指定的端口，等待客户端请求到来。</p></li><li><p>Listen Socket 接受客户端的请求，得到 Client Socket, 接下来通过 Client Socket 与客户端通信。</p></li><li><p>处理客户端的请求，首先从 Client Socket 读取 HTTP 请求的协议头，如果是 POST 方法，还可能要读取客户端提交的数据，然后交给相应的 handler 处理请求，handler 处理完毕准备好客户端需要的数据，通过 Client Socket 写给客户端。</p></li></ol><p>http包中处理过程，附上源码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                log.Printf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c, err := srv.newConn(rw)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> c.serve()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>http连接流程：<br><img src="https://cdn.learnku.com/build-web-application-with-golang/images/3.3.illustrator.png?raw=true" alt=""></p><h2 id="go的http包"><a href="#go的http包" class="headerlink" title="go的http包"></a>go的http包</h2><p>Go 的 http 有两个核心功能：Conn、ServeMux</p><h3 id="Conn的goroutine"><a href="#Conn的goroutine" class="headerlink" title="Conn的goroutine"></a>Conn的goroutine</h3><p>与我们一般编写的 http 服务器不同，Go 为了实现高并发和高性能，使用了 goroutines 来处理 Conn 的读写事件，这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。这是 Go 高效的保证。</p><p>Go 在等待客户端请求里面是这样写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c, err := srv.newConn(rw)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> c.serve()</span><br></pre></td></tr></table></figure><h3 id="ServeMux-的自定义"><a href="#ServeMux-的自定义" class="headerlink" title="ServeMux 的自定义"></a>ServeMux 的自定义</h3><p>ServeMux结构：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.RWMutex   <span class="comment">// 锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry  <span class="comment">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span></span><br><span class="line">    hosts <span class="keyword">bool</span> <span class="comment">// 是否在任意的规则中带有 host 信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    explicit <span class="keyword">bool</span>   <span class="comment">// 是否精确匹配</span></span><br><span class="line">    h        Handler <span class="comment">// 这个路由表达式对应哪个 handler</span></span><br><span class="line">    pattern  <span class="keyword">string</span>  <span class="comment">// 匹配字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)  <span class="comment">// 路由实现器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Go 代码的执行流程<br>通过对 http 包的分析之后，现在让我们来梳理一下整个的代码执行过程。</p><ul><li><p>首先调用 Http.HandleFunc</p><p>按顺序做了几件事：</p><p>1 调用了 DefaultServeMux 的 HandleFunc</p><p>2 调用了 DefaultServeMux 的 Handle</p><p>3 往 DefaultServeMux 的 map [string] muxEntry 中增加对应的 handler 和路由规则</p></li><li><p>其次调用 http.ListenAndServe (“:9090”, nil)</p></li></ul><p>按顺序做了几件事情：</p><pre><code>1 实例化 Server2 调用 Server 的 ListenAndServe ()3 调用 net.Listen (&quot;tcp&quot;, addr) 监听端口4 启动一个 for 循环，在循环体中 Accept 请求5 对每个请求实例化一个 Conn，并且开启一个 goroutine 为这个请求进行服务 go c.serve ()6 读取每个请求的内容 w, err := c.readRequest ()7 判断 handler 是否为空，如果没有设置 handler（这个例子就没有设置 handler），handler 就设置为 DefaultServeMux8 调用 handler 的 ServeHttp9 在这个例子中，下面就进入到 DefaultServeMux.ServeHttp10 根据 request 选择 handler，并且进入到这个 handler 的 ServeHTTP</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mux.handler(r).ServeHTTP(w, r)</span><br></pre></td></tr></table></figure><pre><code>11 选择 handler：A 判断是否有路由能满足这个 request（循环遍历 ServeMux 的 muxEntry）B 如果有路由满足，调用这个路由 handler 的 ServeHTTPC 如果没有路由满足，调用 NotFoundHandler 的 ServeHTTP</code></pre><h1 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h1><h2 id="处理表单输入"><a href="#处理表单输入" class="headerlink" title="处理表单输入"></a>处理表单输入</h2><p>一个简单的表单提交例子，下面前端代码放入login.gtpl文件中<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>login form<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">            用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">            密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>上面递交表单到服务器的 /login，当用户输入信息点击登录之后，会跳转到服务器的路由 login 里面，我们首先要判断这个是什么方式传递过来，POST 还是 GET 呢？</p><p>http 包里面有一个很简单的方式就可以获取，我们在前面 web 的例子的基础上来看看怎么处理 login 页面的 form 数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"html/template"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//HelloServer 请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">r.ParseForm()</span><br><span class="line"><span class="comment">//如果没有调用ParseForm方法，下面无法获取表单数据</span></span><br><span class="line">fmt.Println(r.Form)</span><br><span class="line">fmt.Println(<span class="string">"path:"</span>,r.URL.Path)</span><br><span class="line">fmt.Println(<span class="string">"scheme"</span>,r.URL.Scheme)</span><br><span class="line">fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> r.Form&#123;</span><br><span class="line">fmt.Println(<span class="string">"key:"</span>,k)</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>,v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(w,<span class="string">"Hello world!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"method:"</span>,r.Method)<span class="comment">//获取请求方法</span></span><br><span class="line"><span class="keyword">if</span> r.Method == <span class="string">"GET"</span>&#123;</span><br><span class="line">t,_:=template.ParseFiles(<span class="string">"login.gtpl"</span>)</span><br><span class="line">log.Println(t.Execute(w,<span class="literal">nil</span>))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">err:=r.ParseForm()<span class="comment">//解析url传递的参数，对于POST则解析响应包的主体</span></span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(<span class="string">"ParseForm:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求登录数据，那么执行登录的逻辑判断</span></span><br><span class="line">fmt.Println(<span class="string">"username:"</span>,r.Form[<span class="string">"username"</span>])</span><br><span class="line">fmt.Println(<span class="string">"password:"</span>,r.Form[<span class="string">"password"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/hello"</span>, HelloServer)</span><br><span class="line">http.HandleFunc(<span class="string">"/login"</span>,login)<span class="comment">//</span></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外：</p><ul><li>Request 本身也提供了 FormValue () 函数来获取用户提交的参数。如 r.Form [“username”] 也可写成 r.FormValue (“username”)。调用 r.FormValue 时会自动调用 r.ParseForm，所以不必提前调用。r.FormValue 只会返回同名参数中的第一个，若参数不存在则返回空字符串。</li></ul><h2 id="验证表单的输入"><a href="#验证表单的输入" class="headerlink" title="验证表单的输入"></a>验证表单的输入</h2><h3 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h3><p>确保从一个表单元素中得到一个值，可以通过len获取数据长度进行判断<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(r.Form[<span class="string">"username"</span>][<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//为空处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>r.Form 对不同类型的表单元素的留空有不同的处理， 对于空文本框、空文本区域以及文件上传，元素的值为空值，而如果是未选中的复选框和单选按钮，则根本不会在 r.Form 中产生相应条目，如果我们用上面例子中的方式去获取数据时程序就会报错。所以我们需要通过 r.Form.Get() 来获取值，因为如果字段不存在，通过该方式获取的是空值。但是通过 r.Form.Get() 只能获取单个的值，如果是 map 的值，必须通过上面的方式来获取。</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>确保输入框中的值获取的只能是数字</p><p>例如获取手机号等<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getphone,err:=strconv.Atoi(r.Form.Get(<span class="string">"phone"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//数字转化出错，可能不是数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>或者使用<a href="https://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">正则表达式</a><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m,_:=ragexp.MatchString(<span class="string">"^[0-9]+$"</span>,r.Form.Get(<span class="string">"phone"</span>));!m&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h3><p>还是使用简单点的正则叭<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">"^\\p&#123;Han&#125;+$"</span>, r.Form.Get(<span class="string">"realname"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">"^[a-zA-Z]+$"</span>, r.Form.Get(<span class="string">"engname"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="电子邮箱"><a href="#电子邮箱" class="headerlink" title="电子邮箱"></a>电子邮箱</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^([\w\.\_]&#123;2,10&#125;)@(\w&#123;1,&#125;)\.([a-z]&#123;2,4&#125;)$`</span>, r.Form.Get(<span class="string">"email"</span>)); !m &#123;</span><br><span class="line">    fmt.Println(<span class="string">"no"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"yes"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(1[3|4|5|8][0-9]\d&#123;4,8&#125;)$`</span>, r.Form.Get(<span class="string">"mobile"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉表单"><a href="#下拉表单" class="headerlink" title="下拉表单"></a>下拉表单</h3><p>判断表单里面 &lt;select&gt; 元素生成的下拉菜单中是否有被选中的项目</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;selects name=<span class="string">"fruit"</span>&gt;</span><br><span class="line">&lt;option value="apple"&gt;apple&lt;/option&gt;</span><br><span class="line">&lt;option value="pear"&gt;pear&lt;/option&gt;</span><br><span class="line">&lt;option value="banana"&gt;banana&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>验证：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">string</span>&#123;<span class="string">"apple"</span>,<span class="string">"pear"</span>,<span class="string">"banana"</span>&#125;</span><br><span class="line"></span><br><span class="line">v := r.Form.Get(<span class="string">"fruit"</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    <span class="keyword">if</span> item == v &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>女</span><br></pre></td></tr></table></figure><p>做与多选一样<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">string</span>&#123;<span class="string">"1"</span>,<span class="string">"2"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    <span class="keyword">if</span> v == r.Form.Get(<span class="string">"gender"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"football"</span>&gt;</span>足球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"basketball"</span>&gt;</span>篮球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"tennis"</span>&gt;</span>网球</span><br></pre></td></tr></table></figure><p>验证与单选不同<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">string</span>&#123;<span class="string">"football"</span>,<span class="string">"basketball"</span>,<span class="string">"tennis"</span>&#125;</span><br><span class="line">a:=Slice_diff(r.Form[<span class="string">"interest"</span>],slice)</span><br><span class="line"><span class="keyword">if</span> a==<span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice_diff</span><span class="params">(slice1, slice2 []<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(diffslice []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> slice1 &#123;</span><br><span class="line"><span class="keyword">if</span> !In_slice(v, slice2) &#123;</span><br><span class="line">diffslice = <span class="built_in">append</span>(diffslice, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">In_slice</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;, slice []<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line"><span class="keyword">if</span> v == val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="事件日期"><a href="#事件日期" class="headerlink" title="事件日期"></a>事件日期</h3><p>想确定用户填写的日期或时间是否有效。例如<br>，用户在日程表中安排 8 月份的第 45 天开会，或者提供未来的某个时间作为生日。</p><p>Go 里面提供了一个 time 的处理包，我们可以把用户的输入年月日转化成相应的时间，然后进行逻辑判断<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := time.Date(<span class="number">2009</span>, time.November, <span class="number">10</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.Local)</span><br><span class="line">fmt.Printf(<span class="string">"Go launched at %s\n"</span>, t.Local())</span><br></pre></td></tr></table></figure><p></p><h3 id="身份证号码"><a href="#身份证号码" class="headerlink" title="身份证号码"></a>身份证号码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 15 位身份证，15 位的是全部数字</span></span><br><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(\d&#123;15&#125;)$`</span>, r.Form.Get(<span class="string">"usercard"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 18 位身份证，18 位前 17 位为数字，最后一位是校验位，可能为数字或字符 X。</span></span><br><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(\d&#123;17&#125;)([0-9]|X)$`</span>, r.Form.Get(<span class="string">"usercard"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预防跨站攻击"><a href="#预防跨站攻击" class="headerlink" title="预防跨站攻击"></a>预防跨站攻击</h2><p>对 XSS 最佳的防护应该结合以下两种方法：一是验证所有输入数据，有效检测攻击 (这个我们前面小节已经有过介绍); 另一个是对所有输出数据进行适当的处理，以防止任何已成功注入的脚本在浏览器端运行。<br>Go的html/template里面有几个函数可以进行转义</p><ul><li>func HTMLEscape (w io.Writer, b [] byte) // 把 b 进行转义之后写到 w</li><li>func HTMLEscapeString (s string) string // 转义 s 之后返回结果字符串</li><li>func HTMLEscaper (args …interface {}) string // 支持多个参数一起转义，返回结果字符串<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"text/template"</span></span><br><span class="line">...</span><br><span class="line">t, err := template.New(<span class="string">"foo"</span>).Parse(<span class="string">`&#123;&#123;define "T"&#125;&#125;Hello, &#123;&#123;.&#125;&#125;!&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line">err = t.ExecuteTemplate(out, <span class="string">"T"</span>, <span class="string">"&lt;script&gt;alert('you have been pwned')&lt;/script&gt;"</span>)</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">import</span> <span class="string">"html/template"</span></span><br><span class="line">...</span><br><span class="line">t, err := template.New(<span class="string">"foo"</span>).Parse(<span class="string">`&#123;&#123;define "T"&#125;&#125;Hello, &#123;&#123;.&#125;&#125;!&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line">err = t.ExecuteTemplate(out, <span class="string">"T"</span>, template.HTML(<span class="string">"&lt;script&gt;alert('you have been pwned')&lt;/script&gt;"</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'you have been pwned'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>!</span><br></pre></td></tr></table></figure><p></p><h2 id="防止多次递交表单"><a href="#防止多次递交表单" class="headerlink" title="防止多次递交表单"></a>防止多次递交表单</h2><p>解决方案是在表单中添加一个带有唯一值的隐藏字段。在验证表单时，先检查带有该唯一值的表单是否已经递交过了。如果是，拒绝再次递交；如果不是，则处理表单进行逻辑处理。另外，如果是采用了 Ajax 模式递交表单的话，当表单递交后，通过 javascript 来禁用表单的递交按钮。<br>例子：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"football"</span>&gt;</span>足球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"basketball"</span>&gt;</span>篮球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"tennis"</span>&gt;</span>网球</span><br><span class="line">用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"token"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123;.&#125;&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在模版里面增加了一个隐藏字段 token，这个值我们通过 MD5 (时间戳) 来获取唯一值，然后我们把这个值存储到服务器端(session),方便表单提交时比对判断<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"method:"</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        crutime := time.Now().Unix()</span><br><span class="line">        h := md5.New()</span><br><span class="line">        io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">        token := fmt.Sprintf(<span class="string">"%x"</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"login.gtpl"</span>)</span><br><span class="line">        t.Execute(w, token)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class="line">        r.ParseForm()</span><br><span class="line">        token := r.Form.Get(<span class="string">"token"</span>)</span><br><span class="line">        <span class="keyword">if</span> token != <span class="string">""</span> &#123;</span><br><span class="line">            <span class="comment">// 验证 token 的合法性</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不存在 token 报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"username length:"</span>, <span class="built_in">len</span>(r.Form[<span class="string">"username"</span>][<span class="number">0</span>]))</span><br><span class="line">        fmt.Println(<span class="string">"username:"</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">"username"</span>))) <span class="comment">// 输出到服务器端</span></span><br><span class="line">        fmt.Println(<span class="string">"password:"</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">"password"</span>)))</span><br><span class="line">        template.HTMLEscape(w, []<span class="keyword">byte</span>(r.Form.Get(<span class="string">"username"</span>))) <span class="comment">// 输出到客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="处理上传文件"><a href="#处理上传文件" class="headerlink" title="处理上传文件"></a>处理上传文件</h2><p>要使表单能够上传文件，首先第一步要在form添加enctype属性，它有三种情况<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）</span><br><span class="line">multipart/form-data   不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span><br><span class="line">text/plain    空格转换为 "+" 加号，但不对特殊字符编码。</span><br></pre></td></tr></table></figure><p></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"method:"</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        crutime := time.Now().Unix()</span><br><span class="line">        h := md5.New()</span><br><span class="line">        io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">        token := fmt.Sprintf(<span class="string">"%x"</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"upload.gtpl"</span>)</span><br><span class="line">        t.Execute(w, token)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.ParseMultipartForm(<span class="number">32</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">        file, handler, err := r.FormFile(<span class="string">"uploadfile"</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> file.Close()</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%v"</span>, handler.Header)</span><br><span class="line">        f, err := os.OpenFile(<span class="string">"./test/"</span>+handler.Filename, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)  <span class="comment">// 此处假设当前目录下已存在test目录</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">        io.Copy(f, file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理上传文件三步骤：</p><ol><li>表单增加enctype=”multipart/form-data”</li><li>服务端调用r.ParseMutipartForm，把上传的文件存储再内存和临时文件中</li><li>使用r.FormFile获取文件句柄，然后对文件进行存储处理<h3 id="客户端上传文件"><a href="#客户端上传文件" class="headerlink" title="客户端上传文件"></a>客户端上传文件</h3>模拟客户端表单功能支持文件上传<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"mime/multipart"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postFile</span><span class="params">(filename <span class="keyword">string</span>, targetUrl <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    bodyBuf := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">    bodyWriter := multipart.NewWriter(bodyBuf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键的一步操作</span></span><br><span class="line">    fileWriter, err := bodyWriter.CreateFormFile(<span class="string">"uploadfile"</span>, filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"error writing to buffer"</span>)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件句柄操作</span></span><br><span class="line">    fh, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"error opening file"</span>)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fh.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iocopy</span></span><br><span class="line">    _, err = io.Copy(fileWriter, fh)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contentType := bodyWriter.FormDataContentType()</span><br><span class="line">    bodyWriter.Close()</span><br><span class="line"></span><br><span class="line">    resp, err := http.Post(targetUrl, contentType, bodyBuf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    resp_body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(resp.Status)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(resp_body))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sample usage</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    target_url := <span class="string">"http://localhost:9090/upload"</span></span><br><span class="line">    filename := <span class="string">"./astaxie.pdf"</span></span><br><span class="line">    postFile(filename, target_url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="基本操作（mysql"><a href="#基本操作（mysql" class="headerlink" title="基本操作（mysql)"></a>基本操作（mysql)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">db,err:=sql.Open(<span class="string">"mysql"</span>,<span class="string">"root:123456@tcp(120.78.6.205:3306)/jdbc"</span>)</span><br><span class="line">checkError(err)</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"><span class="comment">// err = db.Ping()</span></span><br><span class="line"><span class="comment">// if err==nil&#123;</span></span><br><span class="line"><span class="comment">// log.Fatal(err)</span></span><br><span class="line"><span class="comment">// &#125;else&#123;</span></span><br><span class="line"><span class="comment">// println("ping....")</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">stmt,err:=db.Prepare(<span class="string">"INSERT employee SET username=?,email=?,gender=?,d_id=?"</span>)</span><br><span class="line">checkError(err)</span><br><span class="line">res,err:=stmt.Exec(<span class="string">"lin"</span>,<span class="string">"linpc@123.com"</span>,<span class="number">1</span>,<span class="number">1001</span>)</span><br><span class="line">checkError(err)</span><br><span class="line">id,err:=res.LastInsertId()</span><br><span class="line">checkError(err)</span><br><span class="line">fmt.Println(id)</span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">stmt,err = db.Prepare(<span class="string">"UPDATE employee SET username=? where id=?"</span>)</span><br><span class="line">checkError(err)</span><br><span class="line">res,err=stmt.Exec(<span class="string">"lincx_py"</span>,id)</span><br><span class="line">checkError(err)</span><br><span class="line">affect,err:=res.RowsAffected()</span><br><span class="line">checkError(err)</span><br><span class="line">fmt.Println(affect)</span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">rows,err:=db.Query(<span class="string">"SELECT * FROM employee"</span>)</span><br><span class="line">checkError(err)</span><br><span class="line"><span class="keyword">for</span> rows.Next()&#123;</span><br><span class="line"><span class="keyword">var</span> id <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> email <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> gender <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> dID <span class="keyword">int</span></span><br><span class="line">err = rows.Scan(&amp;id,&amp;username,&amp;email,&amp;gender,&amp;dID)</span><br><span class="line">checkError(err)</span><br><span class="line">fmt.Println(id)</span><br><span class="line">fmt.Println(username)</span><br><span class="line">fmt.Println(email)</span><br><span class="line">fmt.Println(gender)</span><br><span class="line">fmt.Println(dID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">stmt,err = db.Prepare(<span class="string">"DELETE FROM employee WHERE id=?"</span>)</span><br><span class="line">checkError(err)</span><br><span class="line">res,err = stmt.Exec(id)</span><br><span class="line">checkError(err)</span><br><span class="line">affect,err=res.RowsAffected()</span><br><span class="line">checkError(err)</span><br><span class="line">fmt.Println(affect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><ul><li><p>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">_<span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clearTransaction</span><span class="params">(tx *sql.Tx)</span></span> &#123;</span><br><span class="line">err := tx.Rollback()</span><br><span class="line"><span class="keyword">if</span> err != sql.ErrTxDone &amp;&amp; err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(tx *sql.Tx)</span></span> &#123;</span><br><span class="line">tx.Exec(<span class="string">"INSERT INTO employee(id,username,email,gender,d_id) VALUES(?,?,?,?,?)"</span>,</span><br><span class="line"><span class="number">4</span>,<span class="string">"li"</span>, <span class="string">"1523@k.com"</span>, <span class="number">2</span>, <span class="number">1003</span>)</span><br><span class="line">fmt.Println(<span class="string">"insert"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">(tx *sql.Tx)</span></span>&#123;</span><br><span class="line">tx.Exec(<span class="string">"DELETE FROM employee WHERE id=?"</span>,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(tx *sql.Tx)</span></span>&#123;</span><br><span class="line">rs, err := tx.Exec(<span class="string">"UPDATE employee SET username=? WHERE id=?"</span>, <span class="string">"lincx"</span>, <span class="number">1</span>)</span><br><span class="line">checkError(err)</span><br><span class="line">affact, err := rs.RowsAffected()</span><br><span class="line">checkError(err)</span><br><span class="line">fmt.Println(affact)</span><br><span class="line">fmt.Println(<span class="string">"update"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(db *sql.DB)</span></span>&#123;</span><br><span class="line">rows, err := db.Query(<span class="string">"SELECT * FROM employee"</span>)</span><br><span class="line">checkError(err)</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> id <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> email <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> gender <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> dID <span class="keyword">int</span></span><br><span class="line">err = rows.Scan(&amp;id, &amp;username, &amp;email, &amp;gender, &amp;dID)</span><br><span class="line">checkError(err)</span><br><span class="line">fmt.Println(id)</span><br><span class="line">fmt.Println(username)</span><br><span class="line">fmt.Println(email)</span><br><span class="line">fmt.Println(gender)</span><br><span class="line">fmt.Println(dID)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"query"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(120.78.6.205)/jdbc"</span>)</span><br><span class="line">checkError(err)</span><br><span class="line">tx, err := db.Begin()</span><br><span class="line">checkError(err)</span><br><span class="line"><span class="keyword">defer</span> clearTransaction(tx)</span><br><span class="line">insert(tx)</span><br><span class="line">update(tx)</span><br><span class="line">tx.Commit()</span><br><span class="line">query(db)</span><br><span class="line">db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当query()移到tx.Commit()上面时，只能查到进行insert与update操作前的数据表，查数据库事务的性质才明白，这两个不是同一个线程里面的，事务具有隔离性一致性，在事务结束前，不受到干扰？</p><p>效率上，除了查找之外事务的其他操作效率都是最高的。</p><h1 id="session与数据存储"><a href="#session与数据存储" class="headerlink" title="session与数据存储"></a>session与数据存储</h1><h2 id="session与cookie"><a href="#session与cookie" class="headerlink" title="session与cookie"></a>session与cookie</h2><p>如何抓取一个访问受限的网页？如新浪微博好友的主页，个人微博页面等。</p><p>显然，通过浏览器，我们可以手动输入用户名和密码来访问页面，而所谓的 “抓取”，其实就是使用程序来模拟完成同样的工作，因此我们需要了解 “登陆” 过程中到底发生了什么。</p><p>当用户来到微博登陆页面，输入用户名和密码之后点击 “登录” 后浏览器将认证信息 POST 给远端的服务器，服务器执行验证逻辑，如果验证通过，则浏览器会跳转到登录用户的微博首页，在登录成功后，服务器如何验证我们对其他受限制页面的访问呢？因为 HTTP 协议是无状态的，所以很显然服务器不可能知道我们已经在上一次的 HTTP 请求中通过了验证。当然，最简单的解决方案就是所有的请求里面都带上用户名和密码，这样虽然可行，但大大加重了服务器的负担（对于每个 request 都需要到数据库验证），也大大降低了用户体验 (每个页面都需要重新输入用户名密码，每个页面都带有登录表单)。既然直接在请求中带上用户名与密码不可行，那么就只有在服务器或客户端保存一些类似的可以代表身份的信息了，所以就有了 cookie 与 session。</p><p>cookie，简而言之就是在本地计算机保存一些用户操作的历史信息（当然包括登录信息），并在用户再次访问该站点时浏览器通过 HTTP 协议将本地 cookie 内容发送给服务器，从而完成验证，或继续上一步操作。</p><p><img src="https://cdn.learnku.com/build-web-application-with-golang/images/6.1.cookie2.png?raw=true" alt=""></p><p>session，简而言之就是在服务器上保存用户操作的历史信息。服务器使用 session id 来标识 session，session id 由服务器负责产生，保证随机性与唯一性，相当于一个随机密钥，避免在握手或传输中暴露用户真实密码。但该方式下，仍然需要将发送请求的客户端与 session 进行对应，所以可以借助 cookie 机制来获取客户端的标识（即 session id），也可以通过 GET 方式将 id 提交给服务器。</p><p><img src="https://cdn.learnku.com/build-web-application-with-golang/images/6.1.session.png?raw=true" alt=""></p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>Cookie 是由浏览器维持的，存储在客户端的一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。用户每次访问站点时，Web 应用程序都可以读取 cookie 包含的信息。浏览器设置里面有 cookie 隐私数据选项，打开它，可以看到很多已访问网站的 cookies<br>cookie 是有时间限制的，根据生命期不同分成两种：会话 cookie 和持久 cookie；</p><p>如果不设置过期时间，则表示这个 cookie 的生命周期为从创建到浏览器关闭为止，只要关闭浏览器窗口，cookie 就消失了。这种生命期为浏览会话期的 cookie 被称为会话 cookie。会话 cookie 一般不保存在硬盘上而是保存在内存里。</p><p>如果设置了过期时间 (setMaxAge (606024))，浏览器就会把 cookie 保存到硬盘上，关闭后再次打开浏览器，这些 cookie 依然有效直到超过设定的过期时间。存储在硬盘上的 cookie 可以在不同的浏览器进程间共享，比如两个 IE 窗口。而对于保存在内存的 cookie，不同的浏览器有不同的处理方式。（关闭谷歌浏览器，再打开还是可以定向到上次关闭前的状态</p><p><strong>GO设置cookie</strong><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.SetCookie(w ResponseWriter,cookie *Cookie)</span><br></pre></td></tr></table></figure><p></p><p>cookie对象：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="keyword">string</span></span><br><span class="line">    Value      <span class="keyword">string</span></span><br><span class="line">    Path       <span class="keyword">string</span></span><br><span class="line">    Domain     <span class="keyword">string</span></span><br><span class="line">    Expires    time.Time</span><br><span class="line">    RawExpires <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxAge=0 means no 'Max-Age' attribute specified.</span></span><br><span class="line"><span class="comment">// MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'</span></span><br><span class="line"><span class="comment">// MaxAge&gt;0 means Max-Age attribute present and given in seconds</span></span><br><span class="line">    MaxAge   <span class="keyword">int</span></span><br><span class="line">    Secure   <span class="keyword">bool</span></span><br><span class="line">    HttpOnly <span class="keyword">bool</span></span><br><span class="line">    Raw      <span class="keyword">string</span></span><br><span class="line">    Unparsed []<span class="keyword">string</span> <span class="comment">// Raw text of unparsed attribute-value pairs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>设置cookie</strong><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expiration := time.Now()</span><br><span class="line">expiration = expiration.AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">cookie := http.Cookie&#123;Name: <span class="string">"username"</span>, Value: <span class="string">"astaxie"</span>, Expires: expiration&#125;</span><br><span class="line">http.SetCookie(w, &amp;cookie)</span><br></pre></td></tr></table></figure><p></p><p><strong>读取cookie</strong><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie, _ := r.Cookie(<span class="string">"username"</span>)</span><br><span class="line">fmt.Fprint(w, cookie)</span><br></pre></td></tr></table></figure><p></p><p>或者<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, cookie := <span class="keyword">range</span> r.Cookies() &#123;</span><br><span class="line">    fmt.Fprint(w, cookie.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Go使用session"><a href="#Go使用session" class="headerlink" title="Go使用session"></a>Go使用session</h3><h4 id="session创建过程"><a href="#session创建过程" class="headerlink" title="session创建过程"></a>session创建过程</h4><p>session 的基本原理是由服务器为每个会话维护一份信息数据，客户端和服务端依靠一个全局唯一的标识来访问这份数据，以达到交互的目的。当用户访问 Web 应用时，服务端程序会随需要创建 session，这个过程可以概括为三个步骤：</p><ol><li>生成全局唯一标识符（sessionid）；</li><li>开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务类网站，这将造成严重的后果。所以为了解决这类问题，你可以将会话数据写到文件里或存储在数据库中，当然这样会增加 I/O 开销，但是它可以实现某种程度的 session 持久化，也更有利于 session 的共享；</li><li>将 session 的全局唯一标示符发送给客户端。</li></ol><p>以上三个步骤中，最关键的是如何发送这个 session 的唯一标识这一步上。考虑到 HTTP 协议的定义，数据无非可以放到请求行、头域或 Body 里，所以一般来说会有两种常用的方式：cookie 和 URL 重写</p><ol><li>Cookie<br>服务端通过设置 Set-cookie 头就可以将 session 的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，另外一般包含 session 信息的 cookie 会将失效时间设置为 0 (会话 cookie)，即浏览器进程有效时间。至于浏览器怎么处理这个 0，每个浏览器都有自己的方案，但差别都不会太大 (一般体现在新建浏览器窗口的时候)；</li><li>URL 重写<br>所谓 URL 重写，就是在返回给用户的页面里的所有的 URL 后面追加 session 标识符，这样用户在收到响应之后，无论点击响应页面里的哪个链接或提交表单，都会自动带上 session 标识符，从而就实现了会话的保持。虽然这种做法比较麻烦，但是，如果客户端禁用了 cookie 的话，此种方案将会是首选。</li></ol><h4 id="Go-实现session管理"><a href="#Go-实现session管理" class="headerlink" title="Go 实现session管理"></a>Go 实现session管理</h4><p><strong>session设计</strong></p><p>我们知道 session 管理涉及到如下几个因素</p><ul><li>全局 session 管理器</li><li>保证 sessionid 的全局唯一性</li><li>为每个客户关联一个 session</li><li>session 的存储 (可以存储到内存、文件、数据库等)</li><li>session 过期处理</li></ul><p><strong>session管理器</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Manage <span class="keyword">struct</span>&#123;</span><br><span class="line">    cookieName <span class="keyword">string</span> <span class="comment">//private cookiename</span></span><br><span class="line">    lock sync.Mutex <span class="comment">//protects session</span></span><br><span class="line">    provaider Provider</span><br><span class="line">    maxLifeTime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(provideName, cookieName <span class="keyword">string</span>, maxLifeTime <span class="keyword">int64</span>)</span> <span class="params">(*Manager, error)</span></span> &#123;</span><br><span class="line">    provider, ok := provides[provideName]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"session: unknown provide %q (forgotten import?)"</span>, provideName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;Manager&#123;provider: provider, cookieName: cookieName, maxLifeTime: maxLifeTime&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 实现整个的流程应该也是这样的，在 main 包中创建一个全局的 session 管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalSessions *session.Manager</span><br><span class="line"><span class="comment">// 然后在 init 函数中初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    globalSessions, _ = NewManager(<span class="string">"memory"</span>, <span class="string">"gosessionid"</span>, <span class="number">3600</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 session 是保存在服务器端的数据，它可以以任何的方式存储，比如存储在内存、数据库或者文件中。因此我们抽象出一个 Provider 接口，用以表征 session 管理器底层存储结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Provider <span class="keyword">interface</span> &#123;</span><br><span class="line">    SessionInit(sid <span class="keyword">string</span>) (Session, error)</span><br><span class="line">    SessionRead(sid <span class="keyword">string</span>) (Session, error)</span><br><span class="line">    SessionDestroy(sid <span class="keyword">string</span>) error</span><br><span class="line">    SessionGC(maxLifeTime <span class="keyword">int64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SessionInit 函数实现 Session 的初始化，操作成功则返回此新的 Session 变量</li><li>SessionRead 函数返回 sid 所代表的 Session 变量，如果不存在，那么将以 sid 为参数调用 SessionInit 函数创建并返回一个新的 Session 变量</li><li>SessionDestroy 函数用来销毁 sid 对应的 Session 变量</li><li>SessionGC 根据 maxLifeTime 来删除过期的数据</li></ul><p>那么 Session 接口需要实现什么样的功能呢？有过 Web 开发经验的读者知道，对 Session 的处理基本就设置值、读取值、删除值以及获取当前 sessionID 这四个操作，所以我们的 Session 接口也就实现这四个操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Session <span class="keyword">interface</span> &#123;</span><br><span class="line">    Set(key, value <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// set session value</span></span><br><span class="line">    Get(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// get session value</span></span><br><span class="line">    Delete(key <span class="keyword">interface</span>&#123;&#125;) error     <span class="comment">// delete session value</span></span><br><span class="line">    SessionID() <span class="keyword">string</span>                <span class="comment">// back current sessionID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上设计思路来源于 database/sql/driver，先定义好接口，然后具体的存储 session 的结构实现相应的接口并注册后，相应功能这样就可以使用了，以下是用来随需注册存储 session 的结构的 Register 函数的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> provides = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Provider)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register makes a session provide available by the provided name.</span></span><br><span class="line"><span class="comment">// If Register is called twice with the same name or if driver is nil,</span></span><br><span class="line"><span class="comment">// it panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, provider Provider)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> provider == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"session: Register provider is nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, dup := provides[name]; dup &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"session: Register called twice for provider "</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">    provides[name] = provider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局唯一的 Session ID<br>Session ID 是用来识别访问 Web 应用的每一个用户，因此必须保证它是全局唯一的（GUID），下面代码展示了如何满足这一需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">sessionId</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err := rand.Read(b); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> base64.URLEncoding.EncodeToString(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>session 创建<br>我们需要为每个来访用户分配或获取与他相关连的 Session，以便后面根据 Session 信息来验证操作。SessionStart 这个函数就是用来检测是否已经有某个 Session 与当前来访用户发生了关联，如果没有则创建之。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">SessionStart</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> <span class="params">(session Session)</span></span> &#123;</span><br><span class="line">    manager.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">    cookie, err := r.Cookie(manager.cookieName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value == <span class="string">""</span> &#123;</span><br><span class="line">        sid := manager.sessionId()</span><br><span class="line">        session, _ = manager.provider.SessionInit(sid)</span><br><span class="line">        cookie := http.Cookie&#123;Name: manager.cookieName, Value: url.QueryEscape(sid), Path: <span class="string">"/"</span>, HttpOnly: <span class="literal">true</span>, MaxAge: <span class="keyword">int</span>(manager.maxLifeTime)&#125;</span><br><span class="line">        http.SetCookie(w, &amp;cookie)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sid, _ := url.QueryUnescape(cookie.Value)</span><br><span class="line">        session, _ = manager.provider.SessionRead(sid)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用前面 login 操作来演示 session 的运用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    sess := globalSessions.SessionStart(w, r)</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"login.gtpl"</span>)</span><br><span class="line">        w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">        t.Execute(w, sess.Get(<span class="string">"username"</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"username"</span>, r.Form[<span class="string">"username"</span>])</span><br><span class="line">        http.Redirect(w, r, <span class="string">"/"</span>, <span class="number">302</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作值：设置、读取和删除"><a href="#操作值：设置、读取和删除" class="headerlink" title="操作值：设置、读取和删除"></a>操作值：设置、读取和删除</h4><p>SessionStart 函数返回的是一个满足 Session 接口的变量，那么我们该如何用他来对 session 数据进行操作呢？</p><p>上面的例子中的代码 session.Get(“uid”) 已经展示了基本的读取数据的操作，现在我们再来看一下详细的操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    sess := globalSessions.SessionStart(w, r)</span><br><span class="line">    createtime := sess.Get(<span class="string">"createtime"</span>)</span><br><span class="line">    <span class="keyword">if</span> createtime == <span class="literal">nil</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"createtime"</span>, time.Now().Unix())</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (createtime.(<span class="keyword">int64</span>) + <span class="number">360</span>) &lt; (time.Now().Unix()) &#123;</span><br><span class="line">        globalSessions.SessionDestroy(w, r)</span><br><span class="line">        sess = globalSessions.SessionStart(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">    ct := sess.Get(<span class="string">"countnum"</span>)</span><br><span class="line">    <span class="keyword">if</span> ct == <span class="literal">nil</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"countnum"</span>, <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"countnum"</span>, (ct.(<span class="keyword">int</span>) + <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    t, _ := template.ParseFiles(<span class="string">"count.gtpl"</span>)</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">    t.Execute(w, sess.Get(<span class="string">"countnum"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子可以看到，Session 的操作和操作 key/value 数据库类似: Set、Get、Delete 等操作</p><p>因为 Session 有过期的概念，所以我们定义了 GC 操作，当访问过期时间满足 GC 的触发条件后将会引起 GC，但是当我们进行了任意一个 session 操作，都会对 Session 实体进行更新，都会触发对最后访问时间的修改，这样当 GC 的时候就不会误删除还在使用的 Session 实体。</p><p>session 重置<br>我们知道，Web 应用中有用户退出这个操作，那么当用户退出应用的时候，我们需要对该用户的 session 数据进行销毁操作，上面的代码已经演示了如何使用 session 重置操作，下面这个函数就是实现了这个功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Destroy sessionid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">SessionDestroy</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">    cookie, err := r.Cookie(manager.cookieName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        manager.lock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">        manager.provider.SessionDestroy(cookie.Value)</span><br><span class="line">        expiration := time.Now()</span><br><span class="line">        cookie := http.Cookie&#123;Name: manager.cookieName, Path: <span class="string">"/"</span>, HttpOnly: <span class="literal">true</span>, Expires: expiration, MaxAge: <span class="number">-1</span>&#125;</span><br><span class="line">        http.SetCookie(w, &amp;cookie)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="session-销毁"><a href="#session-销毁" class="headerlink" title="session 销毁"></a>session 销毁</h4><p>我们来看一下 Session 管理器如何来管理销毁，只要我们在 Main 启动的时候启动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> globalSessions.GC()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    manager.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">    manager.provider.SessionGC(manager.maxLifeTime)</span><br><span class="line">    time.AfterFunc(time.Duration(manager.maxLifeTime), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; manager.GC() &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 GC 充分利用了 time 包中的定时器功能，当超时 maxLifeTime 之后调用 GC 函数，这样就可以保证 maxLifeTime 时间内的 session 都是可用的，类似的方案也可以用于统计在线用户数之类的。</p><h2 id="session存储"><a href="#session存储" class="headerlink" title="session存储"></a>session存储</h2><p>上代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> memory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"container/list"</span></span><br><span class="line">    <span class="string">"github.com/astaxie/session"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pder = &amp;Provider&#123;list: list.New()&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SessionStore <span class="keyword">struct</span> &#123;</span><br><span class="line">    sid          <span class="keyword">string</span>                      <span class="comment">// session id唯一标示</span></span><br><span class="line">    timeAccessed time.Time                   <span class="comment">// 最后访问时间</span></span><br><span class="line">    value        <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// session里面存储的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    st.value[key] = value</span><br><span class="line">    pder.SessionUpdate(st.sid)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    pder.SessionUpdate(st.sid)</span><br><span class="line">    <span class="keyword">if</span> v, ok := st.value[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(st.value, key)</span><br><span class="line">    pder.SessionUpdate(st.sid)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">SessionID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> st.sid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock     sync.Mutex               <span class="comment">// 用来锁</span></span><br><span class="line">    sessions <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element <span class="comment">// 用来存储在内存</span></span><br><span class="line">    list     *list.List               <span class="comment">// 用来做 gc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionInit</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="params">(session.Session, error)</span></span> &#123;</span><br><span class="line">    pder.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pder.lock.Unlock()</span><br><span class="line">    v := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    newsess := &amp;SessionStore&#123;sid: sid, timeAccessed: time.Now(), value: v&#125;</span><br><span class="line">    element := pder.list.PushBack(newsess)</span><br><span class="line">    pder.sessions[sid] = element</span><br><span class="line">    <span class="keyword">return</span> newsess, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionRead</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="params">(session.Session, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> element.Value.(*SessionStore), <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sess, err := pder.SessionInit(sid)</span><br><span class="line">        <span class="keyword">return</span> sess, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionDestroy</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pder.sessions, sid)</span><br><span class="line">        pder.list.Remove(element)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionGC</span><span class="params">(maxlifetime <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    pder.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pder.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        element := pder.list.Back()</span><br><span class="line">        <span class="keyword">if</span> element == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (element.Value.(*SessionStore).timeAccessed.Unix() + maxlifetime) &lt; time.Now().Unix() &#123;</span><br><span class="line">            pder.list.Remove(element)</span><br><span class="line">            <span class="built_in">delete</span>(pder.sessions, element.Value.(*SessionStore).sid)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionUpdate</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    pder.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pder.lock.Unlock()</span><br><span class="line">    <span class="keyword">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class="line">        element.Value.(*SessionStore).timeAccessed = time.Now()</span><br><span class="line">        pder.list.MoveToFront(element)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pder.sessions = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element, <span class="number">0</span>)</span><br><span class="line">    session.Register(<span class="string">"memory"</span>, pder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面这个代码实现了一个内存存储的 session 机制。通过 init 函数注册到 session 管理器中。这样就可以方便的调用了。我们如何来调用该引擎呢？请看下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/astaxie/session"</span></span><br><span class="line">    _ <span class="string">"github.com/astaxie/session/providers/memory"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当 import 的时候已经执行了 memory 函数里面的 init 函数，这样就已经注册到 session 管理器中，我们就可以使用了，通过如下方式就可以初始化一个 session 管理器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalSessions *session.Manager</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在 init 函数中初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    globalSessions, _ = session.NewManager(<span class="string">"memory"</span>, <span class="string">"gosessionid"</span>, <span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">go</span> globalSessions.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预防劫持"><a href="#预防劫持" class="headerlink" title="预防劫持"></a>预防劫持</h3><p><strong>cookieonly和token</strong><br>其中一个解决方案就是 sessionID 的值只允许 cookie 设置，而不是通过 URL 重置方式设置，同时设置 cookie 的 httponly 为 true, 这个属性是设置是否可通过客户端脚本访问这个设置的 cookie，第一这个可以防止这个 cookie 被 XSS 读取从而引起 session 劫持，第二 cookie 设置不会像 URL 重置方式那么容易获取 sessionID。<br>第二步就是在每个请求里面加上 token，实现类似前面章节里面讲的防止 form 重复递交类似的功能，我们在每个请求里面加上一个隐藏的 token，然后每次验证这个 token，从而保证用户的请求都是唯一性。<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">h := md5.New()</span><br><span class="line">salt:=<span class="string">"astaxie%^7&amp;8888"</span></span><br><span class="line">io.WriteString(h,salt+time.Now().String())</span><br><span class="line">token:=fmt.Sprintf(<span class="string">"%x"</span>,h.Sum(<span class="literal">nil</span>))</span><br><span class="line"><span class="keyword">if</span> r.Form[<span class="string">"token"</span>]!=token&#123;</span><br><span class="line">    <span class="comment">// 提示登录</span></span><br><span class="line">&#125;</span><br><span class="line">sess.Set(<span class="string">"token"</span>,token)</span><br></pre></td></tr></table></figure><p></p><p><strong>间隔生成新的 SID</strong></p><p>还有一个解决方案就是，我们给 session 额外设置一个创建时间的值，一旦过了一定的时间，我们销毁这个 sessionID，重新生成新的 session，这样可以一定程度上防止 session 劫持的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">createtime := sess.Get(<span class="string">"createtime"</span>)</span><br><span class="line"><span class="keyword">if</span> createtime == <span class="literal">nil</span> &#123;</span><br><span class="line">    sess.Set(<span class="string">"createtime"</span>, time.Now().Unix())</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (createtime.(<span class="keyword">int64</span>) + <span class="number">60</span>) &lt; (time.Now().Unix()) &#123;</span><br><span class="line">    globalSessions.SessionDestroy(w, r)</span><br><span class="line">    sess = globalSessions.SessionStart(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>session 启动后，我们设置了一个值，用于记录生成 sessionID 的时间。通过判断每次请求是否过期 (这里设置了 60 秒) 定期生成新的 ID，这样使得攻击者获取有效 sessionID 的机会大大降低。</p><p>上面两个手段的组合可以在实践中消除 session 劫持的风险，一方面，由于 sessionID 频繁改变，使攻击者难有机会获取有效的 sessionID；另一方面，因为 sessionID 只能在 cookie 中传递，然后设置了 httponly，所以基于 URL 攻击的可能性为零，同时被 XSS 获取 sessionID 也不可能。最后，由于我们还设置了 MaxAge=0，这样就相当于 session cookie 不会留在浏览器的历史记录里面。</p><p>本文部分内容转自链接：<a href="https://learnku.com/docs/build-web-application-with-golang/031-web-working-mode/3168" target="_blank" rel="noopener">https://learnku.com/docs/build-web-application-with-golang/031-web-working-mode/3168</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Go-Web开发&quot;&gt;&lt;a href=&quot;#Go-Web开发&quot; class=&quot;headerlink&quot; title=&quot;Go Web开发&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="go" scheme="https://lincx_py.gitee.io/categories/go/"/>
    
    
      <category term="GoWeb" scheme="https://lincx_py.gitee.io/tags/GoWeb/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析</title>
    <link href="https://lincx_py.gitee.io/2020/03/31/alt1/"/>
    <id>https://lincx_py.gitee.io/2020/03/31/alt1/</id>
    <published>2020-03-31T15:15:35.000Z</published>
    <updated>2020-03-31T15:29:04.926Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --><h2 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h2><p>运用递归思想解决一些数学问题，可以用简单穷举找出相关的规律，总结出递归公式，然年套用公式编成程序</p><p><img src="https://ae01.alicdn.com/kf/H14c460974fc143208600a715c29f7153a.png" alt=""></p><p>代码：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> fy,<span class="keyword">int</span> hy)</span></span>&#123;</span><br><span class="line"><span class="comment">//fy表示50元</span></span><br><span class="line"><span class="comment">//hy表示100元 </span></span><br><span class="line"><span class="keyword">if</span>(fy==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(hy==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> func(fy<span class="number">-1</span>,hy)+func(fy<span class="number">-1</span>,hy<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> fy,<span class="keyword">int</span> hy)</span></span>&#123;</span><br><span class="line"><span class="comment">//fy表示50元</span></span><br><span class="line"><span class="comment">//hy表示100元 </span></span><br><span class="line"><span class="keyword">if</span>(hy==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(fy&lt;hy)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> func1(fy<span class="number">-1</span>,hy)+func1(fy,hy<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;func1(i,i)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;func1(i,i)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><p><img src="https://ae01.alicdn.com/kf/Hdce7e182d3414a97ac3445b95a0541cfE.png" alt=""></p><p>代码：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=now;i&lt;=n/k;i++)&#123;</span><br><span class="line">s+=func(n<span class="number">-1</span>,k<span class="number">-1</span>,i);<span class="comment">//降模 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>];<span class="comment">//储存每次结果 </span></span><br><span class="line"><span class="keyword">int</span> s1=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> pos)</span></span>&#123;<span class="comment">//全局变量 </span></span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">++s1;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pos;j++)<span class="built_in">cout</span>&lt;&lt;a[j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=a[pos<span class="number">-1</span>];i&lt;n/k;i++)&#123;</span><br><span class="line">a[pos]=i; </span><br><span class="line">func1(now<span class="number">-1</span>,k<span class="number">-1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">15</span>,k=<span class="number">6</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;func(n,k,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 21 2021 18:56:31 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;递归思想&quot;&gt;&lt;a href=&quot;#递归思想&quot; class=&quot;headerlink&quot; title=&quot;递归思想&quot;&gt;&lt;/a&gt;递归思想&lt;/h2&gt;
      
    
    </summary>
    
      <category term="c/c++" scheme="https://lincx_py.gitee.io/categories/c-c/"/>
    
    
      <category term="algorithm" scheme="https://lincx_py.gitee.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
